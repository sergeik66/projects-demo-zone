    - task: PowerShell@2
      displayName: 'Deploy SQL Views to Lakehouse SQL Endpoint'
      inputs:
        targetType: 'inline'
        pwsh: true
        script: |
          $ErrorActionPreference = "Stop"

          # === INPUTS ===
          $workspaceId     = $env:WORKSPACE_ID
          $lakehouseName   = "${{ parameters.sqlViewsLakehouse }}"
          $sourceFolder    = "$(System.DefaultWorkingDirectory)/${{ parameters.sqlViewsFolder }}"

          if ([string]::IsNullOrWhiteSpace($lakehouseName)) {
              Write-Host "##[warning]sqlViewsLakehouse parameter not set – skipping SQL views deployment."
              exit 0
          }

          if (-not (Test-Path $sourceFolder)) {
              Write-Host "##[warning]SQL views folder not found: $sourceFolder – skipping."
              exit 0
          }

          $sqlFiles = Get-ChildItem -Path $sourceFolder -Filter "*.sql" -Recurse
          if ($sqlFiles.Count -eq 0) {
              Write-Host "No .sql files found in $sourceFolder – nothing to deploy."
              exit 0
          }

          Write-Host "Deploying $($sqlFiles.Count) SQL view(s) to lakehouse '$lakehouseName'"

          # Load modern SQL client
          Add-Type -AssemblyName "Microsoft.Data.SqlClient"

          # === Get Lakehouse Item ID via Fabric REST API ===
          $headers = @{ Authorization = "Bearer $env:FABRIC_TOKEN" }
          $uri = "https://api.fabric.microsoft.com/v1/workspaces/$workspaceId/items?type=Lakehouse"

          $items = (Invoke-RestMethod -Uri $uri -Headers $headers -Method Get).value
          $lakehouse = $items | Where-Object { $_.displayName -eq $lakehouseName }

          if (-not $lakehouse) {
              Write-Error "Lakehouse '$lakehouseName' not found in workspace $workspaceId"
              exit 1
          }

          $lakehouseId = $lakehouse.id
          Write-Host "Lakehouse found → ID: $lakehouseId"

          # === THIS IS THE ONLY FORMAT THAT WORKS (2025) ===
          $server = "${workspaceId}-${lakehouseId}.datawarehouse.fabric.microsoft.com"

          # Minimal connection string – no port, no database name
          $connectionString = "Server=$server;Encrypt=True;TrustServerCertificate=False;Connection Timeout=60;"

          $connection = New-Object Microsoft.Data.SqlClient.SqlConnection($connectionString)

          # AAD token for the SQL endpoint
          $token = (Get-AzAccessToken -ResourceUrl "https://database.windows.net").Token
          $connection.AccessToken = $token

          try {
              $connection.Open()
              Write-Host "##[section]Connected successfully to $server"
          }
          catch {
              Write-Error "Failed to connect to $server. Error: $($_.Exception.Message)"
              throw
          }

          foreach ($file in $sqlFiles) {
              Write-Host "Executing → $($file.Name)"
              $sql = Get-Content -Path $file.FullName -Raw -Encoding UTF8

              # Split on GO (case-insensitive, multiline-safe)
              $batches = $sql -split '(?im)^\s*GO\s*$' |
                         ForEach-Object { $_.Trim() } |
                         Where-Object { $_ }

              foreach ($batch in $batches) {
                  $cmd = $connection.CreateCommand()
                  $cmd.CommandText = $batch
                  $cmd.CommandTimeout = 300

                  try {
                      $cmd.ExecuteNonQuery() | Out-Null
                  }
                  catch {
                      Write-Error "Failed in file '$($file.Name)': $($_.Exception.Message)"
                      Write-Host "##[error]Offending batch:`n$batch"
                      throw
                  }
              }
              Write-Host "  Success $($file.Name)"
          }

          $connection.Close()
          Write-Host "##[section]All SQL views deployed successfully to lakehouse '$lakehouseName'!"

        errorActionPreference: 'stop'
        failOnStderr: true

      env:
        FABRIC_TOKEN: $(FABRIC_TOKEN)
        WORKSPACE_ID: $(WORKSPACE_ID)

      condition: and(succeeded(), ne('${{ parameters.sqlViewsLakehouse }}', ''))
6h47pwihyocerltcbmj6jgzgta-l3k4gas4jcnudnmhegsrv2zgdy.datawarehouse.fabric.microsoft.com
parameters:
  - name: sqlViewsLakehouse
    type: string
    displayName: 'Lakehouse Name for SQL Views Deployment'
    default: 'den_lhw_pdi_001_policy'  # <<< CHANGE THIS TO YOUR ACTUAL LAKEHOUSE NAME >>>
  - name: sqlViewsFolder
    type: string
    displayName: 'Source folder that contains the .sql view files'
    default: 'src/sql/views'  # <<< ADJUST IF YOUR VIEWS ARE IN A DIFFERENT FOLDER >>>

# Add this task to the deploy_fabric_resources job` (I recommend placing it after the “Configure and Deploy Reports” task or after “Fabric Data Pipelines Configuration” – anywhere after shortcuts are created and before notebooks are run):    
    - task: PowerShell@2
      displayName: 'Deploy SQL Views to Lakehouse SQL Endpoint'
      inputs:
        targetType: 'inline'
        pwsh: true
        script: |
          $ErrorActionPreference = "Stop"

          $workspaceId = $env:WORKSPACE_ID
          $lakehouseName = "${{ parameters.sqlViewsLakehouse }}"

          if ([string]::IsNullOrWhiteSpace($lakehouseName)) {
              Write-Host "##[warning]No lakehouse specified for SQL views – skipping."
              exit 0
          }

          $viewsDirectory = "$(System.DefaultWorkingDirectory)/${{ parameters.sqlViewsFolder }}"
          if (-not (Test-Path $viewsDirectory)) {
              Write-Host "##[warning]Views directory '$viewsDirectory' not found – skipping."
              exit 0
          }

          $sqlFiles = Get-ChildItem -Path $viewsDirectory -Filter "*.sql" -Recurse
          if ($sqlFiles.Count -eq 0) {
              Write-Host "##[warning]No .sql files found in '$viewsDirectory' – nothing to deploy."
              exit 0
          }

          Write-Host "Deploying $($sqlFiles.Count) SQL view(s) to lakehouse '$lakehouseName' in workspace $workspaceId"

          # Load Microsoft.Data.SqlClient (preferred for Fabric TDS endpoints)
          Add-Type -AssemblyName "Microsoft.Data.SqlClient"

          # Fetch Lakehouse GUID via Fabric REST API
          $headers = @{
              "Authorization" = "Bearer $env:FABRIC_TOKEN"
              "Content-Type" = "application/json"
          }
          $uri = "https://api.fabric.microsoft.com/v1/workspaces/$workspaceId/items?itemType=LAKEHOUSE"
          $response = Invoke-RestMethod -Uri $uri -Headers $headers -Method Get

          $lakehouseItem = $response.value | Where-Object { $_.displayName -eq $lakehouseName }
          if (-not $lakehouseItem) {
              Write-Error "Lakehouse '$lakehouseName' not found in workspace '$workspaceId'"
              exit 1
          }
          $lakehouseId = $lakehouseItem.id
          Write-Host "Found Lakehouse GUID: $lakehouseId"

          # Correct Fabric SQL endpoint server format
          $server = "$workspaceId-$lakehouseId.datawarehouse.fabric.microsoft.com:1433"
          $connectionString = "Server=tcp:$server;Initial Catalog=$lakehouseName;Encrypt=True;TrustServerCertificate=False;Connection Timeout=60;"

          $connection = New-Object Microsoft.Data.SqlClient.SqlConnection($connectionString)

          # Use AAD token for https://database.windows.net (valid for Fabric SQL endpoints)
          $token = (Get-AzAccessToken -ResourceUrl "https://database.windows.net").Token
          $connection.AccessToken = $token
          $connection.Open()
          Write-Host "Connected successfully to Fabric SQL endpoint: $server"

          foreach ($file in $sqlFiles) {
              Write-Host "Executing file: $($file.Name)"
              $sqlContent = Get-Content -Path $file.FullName -Raw -Encoding UTF8

              # Improved GO batch splitting (case-insensitive, handles whitespace/newlines)
              $batches = $sqlContent -split '(?im)^\s*GO\s*$' | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' }

              foreach ($batch in $batches) {
                  $command = $connection.CreateCommand()
                  $command.CommandText = $batch
                  $command.CommandTimeout = 300  # 5 minutes per batch

                  try {
                      $rowsAffected = $command.ExecuteNonQuery()
                      Write-Host "  → Batch executed: $rowsAffected row(s) affected"
                  } catch {
                      Write-Error "Failed to execute batch in '$($file.Name)': $($_.Exception.Message)"
                      $connection.Close()
                      throw
                  }
              }
              Write-Host "  ✓ File '$($file.Name)' completed successfully"
          }

          $connection.Close()
          Write-Host "##[section]All SQL views deployed successfully to lakehouse '$lakehouseName'!"
        errorActionPreference: 'stop'
        failOnStderr: true
      env:
        FABRIC_TOKEN: $(FABRIC_TOKEN)
        WORKSPACE_ID: $(WORKSPACE_ID)
      condition: and(succeeded(), ne('${{ parameters.sqlViewsLakehouse }}', ''))

parameters:
  - name: isGitConnect
    type: boolean
    displayName: 'Sync Initialize Workspace to Git?'
    default: false

  - name: waitJobsToFinish
    type: boolean
    displayName: 'Wait for Jobs to Finish?'
    default: false

  - name: forceDeletionPPE
    type: boolean
    displayName: 'Force Deletion of Managed Private Endpoint?'
    default: false

  - name: upgradeSparkLibraries
    type: boolean
    displayName: 'Upgrade spark library?'
    default: false

  - name: variableGroup
    displayName: 'Variable Group'
    type: string
    default: 'PlatformServices'    

trigger:
  branches:
    include: [main]
  paths:
    include: [terraform/*]

variables:
  - group: ${{ parameters.variableGroup }}
 
  - name: workingDirectory
    value: $(System.DefaultWorkingDirectory)/DevOpsServices/terraform/PlatformServices
  - name: agentPool
    value: GDAP-Fluidity-PlatformServices_Self-hosted-AgentPool

pool:
  name: $(agentPool)
  vmImage: windows-latest

stages:
- stage: Validate_Infrastructure
  displayName: 'Validate Infrastructure Configuration'
  jobs:
  - job: validate_terraform_configuration
    displayName: 'Validate Terraform Configuration'
    steps:
    - checkout: self
      displayName: 'Checkout Repository'
     
    - template: ../templates/auth-setup.yml
     
    - template: ../templates/terraform-setup.yml
   
    - script: |
        terraform fmt -check
        terraform validate
      workingDirectory: $(workingDirectory)
      displayName: 'Validate Terraform Format and Configuration'
  - job: validate_git_environment
    dependsOn: validate_terraform_configuration
    displayName: 'Validate Git Configuration'
    steps:
    - task: PowerShell@2
      inputs:
        targetType: 'inline'
        script: |
          $isGitConnect = [System.Convert]::ToBoolean("${{ parameters.isGitConnect }}")
          $environment = "$(ENVIRONMENT)"
         
          Write-Host "isGitConnect: $isGitConnect"
          Write-Host "Environment: $environment"
         
          if ($isGitConnect -eq $true -and $environment -ne 'int') {
              Write-Host "##vso[task.LogIssue type=error;]Error: Git sync is only allowed in 'int' environment. Current environment is '$environment'"
              Write-Host "##vso[task.complete result=Failed;]"
              exit 1
          }
         
          Write-Host "Validation passed"
      displayName: 'Validate Git Connect Environment'  
 
- stage: Deploy_Infrastructure
  displayName: 'Deploy Infrastructure Components'
  
  dependsOn: Validate_Infrastructure
  condition: succeeded('Validate_Infrastructure')
  jobs:   
  - deployment: pending_approval
    displayName: 'Pending Approval for Infrastructure Deployment'
    environment: $(PIPELINE_ENVIRONMENT_APPROVAL)   
 
  - job: deploy_fabric_resources
    displayName: 'Deploy Fabric Resources and Configure Services'
    steps:
    - checkout: self
    - template: ../templates/auth-setup.yml
    - template: ../templates/convert-notebooks.yml
    - template: ../templates/terraform-setup.yml
   
    - task: PowerShell@2
      inputs:
        targetType: 'inline'
        script: |

          # Check if Az modules are already installed
          $requiredModules = @(
              'Az.Accounts'
          )

          foreach ($module in $requiredModules) {
              if (!(Get-Module -Name $module -ListAvailable)) {
                  Write-Host "Installing $module..."
                  Install-PackageProvider -Name NuGet -Force -Scope CurrentUser -ErrorAction SilentlyContinue
                  Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
                  Install-Module -Name $module -Force -AllowClobber -Scope CurrentUser -Confirm:$false
              } else {
                  Write-Host "$module already installed"
              }
          }
           
          # Import only needed modules
          Import-Module Az.Accounts -DisableNameChecking

          Clear-AzContext -Force
         
          Update-AzConfig -LoginExperienceV2 off
          Update-AzConfig -EnableLoginByWam $false

          $username = '$(SERVICE_ACCOUNT_NAME)'
          $userPwd = '$(SERVICE_ACCOUNT_SECRET)' | ConvertTo-SecureString -AsPlainText -Force
          $credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $username, $userPwd

          Connect-AzAccount -Tenant $(ARM_TENANT_ID) -Credential $credential -AuthScope 'api://spn-gdap-fabricpview-usercontext'

          $secureFabricToken = (Get-AzAccessToken -ResourceUrl 'https://api.fabric.microsoft.com' -AsSecureString).Token

          $Ptr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($secureFabricToken)
          $fabricToken = [System.Runtime.InteropServices.Marshal]::PtrToStringBSTR($Ptr)
          $env:FABRIC_TOKEN = $fabricToken
          Write-Host "##vso[task.setvariable variable=FABRIC_TOKEN]$fabricToken"

      displayName: 'Configure Azure Authentication and Get Fabric Token'    

    - task: PowerShell@2
      inputs:
        targetType: 'inline'
        script: |

          $scriptPath = "$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts/Fabric-CapacityState.ps1"
          & $scriptPath 
          # exits if Fabric-CapacityState.ps1 returns non-zero exit code
          if ($LASTEXITCODE -ne 0) {
              Write-Host "##vso[task.LogIssue type=error;]Fabric Capacity State validation failed."
              Write-Host "##vso[task.complete result=Failed;]"
              exit 1
            } else {
              Write-Host "Fabric Capacity State is active."
            }
        pwsh: false
        workingDirectory: '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts'
      env:
        FABRIC_TOKEN: $env:FABRIC_TOKEN
        TF_VAR_capacity_id: $(TF_VAR_capacity_id)
      displayName: 'Validate Fabric Capacity State'  

    - task: PowerShell@2
      name: prepShortcutVars
      displayName: 'Prepare Lakehouse Shortcut Variables'
      inputs:
        targetType: 'inline'
        script: |
          try {
              # Initialize empty array for formatted shortcuts
              $detailedShortcuts = @()
              $shortcutGroups = @{}
           
              Write-Host "##[debug]Processing shortcut variables from environment..."
           
              # Iterate through all environment variables
              foreach ($item in (Get-Item env:*)) {
                  # Check if it's a shortcut variable (starts with 'shortcut.')

                  if ($item.Name.ToLower().StartsWith('shortcut_')) {
                      $logicalName = $item.Name.ToLower()
                  
                      $logicalName = $logicalName -replace '^shortcut_', 'shortcut.'

                      $lastUnderscoreIndex = $logicalName.LastIndexOf('_')
                      if ($lastUnderscoreIndex -gt 0) {
                          $logicalName = $logicalName.Substring(0, $lastUnderscoreIndex) + '.' + $logicalName.Substring($lastUnderscoreIndex + 1)
                      }

                      Write-Host "##[debug]Found shortcut variable: $($item.Name) = $($item.Value)"
                   
                      # Parse the variable name: shortcut.{name}.{property}
                      $nameParts = $logicalName -split "\."
                   
                      # Skip if the format is incorrect
                      if ($nameParts.Length -ne 3) {
                          Write-Host "##[warning]Invalid shortcut variable format: $($item.Name). Expected format: shortcut.{name}.{property}"
                          continue
                      }
                   
                      $shortcutName = $nameParts[1]
                      $propertyName = $nameParts[2]
                      $propertyValue = $item.Value
                   
                      # Initialize the shortcut object if it doesn't exist
                      if (-not $shortcutGroups.ContainsKey($shortcutName)) {
                          $shortcutGroups[$shortcutName] = @{}
                      }
                   
                      # Add the property to the shortcut
                      $shortcutGroups[$shortcutName][$propertyName] = $propertyValue
                  }
              }
           
              # Transform the grouped shortcuts into an array of objects
              foreach ($name in $shortcutGroups.Keys) {
                  $properties = $shortcutGroups[$name]
               
                  # Only add shortcuts that have both required properties
                  $WorkspaceName = $env:TF_VAR_workspace_names
                  $WorkspaceName = $WorkspaceName.Replace('[', '["').Replace(']', '"]').Replace(',', '","') -replace '"\s+', '"'
                  $WorkspaceName = $WorkspaceName.Trim('[', ']').Trim('"')
                  if ($properties.ContainsKey("lakehouse") -and $properties.ContainsKey("workspace")) {
                      $detailedShortcuts += [PSCustomObject]@{
                        name = $name
                        workspace = $properties["workspace"]
                        lakehouse = $properties["lakehouse"]
                      }                   
                      Write-Host "##[debug]Added shortcut: $name (Lakehouse: $($properties["lakehouse"]), Workspace: $($properties["workspace"]))"
                  }
                  else {
                      $detailedShortcuts += [PSCustomObject]@{
                        name = $name
                        workspace = $WorkspaceName
                        lakehouse = $properties["lakehouse"]
                      }                  
                      Write-Host "##[debug]Added shortcut: $name (Lakehouse: $($properties["lakehouse"]), Workspace: $WorkspaceName)"
                  }
              }
           
              # Check if any valid shortcuts were found
              if ($detailedShortcuts.Count -eq 0) {
                  Write-Host "##[warning]No valid shortcut variables found with both lakehouse and workspace properties"
              } else {
                  Write-Host "##[debug]Processed $($detailedShortcuts.Count) valid shortcut definitions"              

                  # Convert to JSON
                  $detailedShortcutsJson = $detailedShortcuts | ConvertTo-Json -Depth 5 -Compress
               
                  if ($detailedShortcuts.Count -eq 1) {
                    # prepend and append brackets to make it a JSON array
                    $detailedShortcutsJson = "[$detailedShortcutsJson]"
                  }
                   
                  # Log the JSON for debugging
                  Write-Host "##[debug]Detailed Shortcuts JSON: $detailedShortcutsJson"
               
                  # Set as pipeline variable
                  Write-Host "##vso[task.setvariable variable=FABRIC_SHORTCUTS_DETAILED]$detailedShortcutsJson"
              }
          } catch {
              Write-Error "Error processing shortcut variables: $_"
              Write-Error $_.ScriptStackTrace
              exit 1
          }

    - task: PowerShell@2
      name: prepPrivateEndpointsVars
      displayName: 'Prepare Private Endpoints Variables (PEP)'
      inputs:
        targetType: 'inline'
        script: |
          try {
              # Initialize empty array for formatted PEP
              $detailedPEPs = @()
              $PEPGroups = @{}
           
              Write-Host "##[debug]Processing PEP variables from environment..."
           
              # Iterate through all environment variables
              foreach ($item in (Get-Item env:*)) {
                  # Check if it's a pep variable (starts with 'pep.')

                  if ($item.Name.ToLower().StartsWith('pep_')) {
                      $item.Name = $item.Name.ToLower().Replace('pep_', 'pep.').Replace('_', '.')
                  }
                  if ($item.Name -like "pep.*") {
                      Write-Host "##[debug]Found PEP variable: $($item.Name) = $($item.Value)"
                   
                      # Parse the variable name: pep.{name}.{property}
                      $nameParts = $item.Name -split "\."
                   
                      # Skip if the format is incorrect
                      if ($nameParts.Length -ne 3) {
                          Write-Host "##[warning]Invalid pep variable format: $($item.Name). Expected format: pep.{name}.{property}"
                          continue
                      }
                   
                      $pepName = $nameParts[1]
                      $propertyName = $nameParts[2]
                      $propertyValue = $item.Value
                   
                      # Initialize the PEP object if it doesn't exist
                      if (-not $PEPGroups.ContainsKey($pepName)) {
                          $PEPGroups[$pepName] = @{}
                      }
                   
                      # Add the property to the PEP
                      $PEPGroups[$pepName][$propertyName] = $propertyValue
                  }
              }
           
              # Transform the grouped PEPs into an array of objects
              foreach ($name in $PEPGroups.Keys) {
                  $properties = $PEPGroups[$name]

                  $detailedPEPs += [PSCustomObject]@{
                        allowed = $properties["allowed"]
                        resourceId = $properties["resourceId"]
                        subresourceType = $properties["subresourceType"]
                    }
                 
                  Write-Host "##[debug]Added PEP: $name (Allowed: $($properties["allowed"]), resourceId: $($properties["resourceId"]), subresourceType: $($properties["subresourceType"]))"
              }
           
              # Check if any valid PEP were found
              if ($detailedPEPs.Count -eq 0) {
                  Write-Host "##[warning]No valid PEP variables found with both allowed and resourceId properties"
              } else {
                  Write-Host "##[debug]Processed $($detailedPEPs.Count) valid PEP definitions"              

                  # Convert to JSON
                  $detailedPEPJson = $detailedPEPs | ConvertTo-Json -Depth 5 -Compress
               
                  if ($detailedPEPs.Count -eq 1) {
                    # prepend and append brackets to make it a JSON array
                    $detailedPEPJson = "[$detailedPEPJson]"
                  }
                   
                  # Log the JSON for debugging
                  Write-Host "##[debug]Detailed PEPs JSON: $detailedPEPJson"
               
                  # Set as pipeline variable
                  Write-Host "##vso[task.setvariable variable=FABRIC_PEP_DETAILED]$detailedPEPJson"
              }

              $formattedSparkCompute = @{}
              foreach ($item in (Get-Item env:*)) { 
                  if ($item.Name.ToLower().StartsWith('sparkcompute_')) {
                      # Extract original name without prefix
                      $displayName = $item.Name.ToLower().Replace('sparkcompute_', '')

                      # Add formatted spark compute object
                      $formattedSparkCompute[$displayName] = $item.Value

                  }
              }
              Write-Host "##[debug]Formatted Spark Compute: $($formattedSparkCompute | ConvertTo-Json -Compress)"

              $sparkComputeJson = $formattedSparkCompute | ConvertTo-Json -Compress              
              Write-Host "##vso[task.setvariable variable=FABRIC_SPARK_COMPUTE]$sparkComputeJson"

          } catch {
              Write-Error "Error processing PEP variables: $_"
              Write-Error $_.ScriptStackTrace
              exit 1
          }

    - task: PowerShell@2
      name: prepSemanticModelVars
      displayName: 'Prepare Semantic Model Lakehouse Variables'
      inputs:
        targetType: 'inline'
        script: |
          try {
              # Initialize empty array for formatted shortcuts
              $detailedSemanticModels = @()
              $semanticModelGroups = @{}
           
              Write-Host "##[debug]Processing semantic model variables ..."
           
              # Iterate through all environment variables
              foreach ($item in (Get-Item env:*)) {
                  # Check if it's a semantic model variable (starts with 'sm.')

                  if ($item.Name.ToLower().StartsWith('sm_')) {
                      $logicalName = $item.Name.ToLower()
                  
                      $logicalName = $logicalName -replace '^sm_', 'sm.'

                      $lastUnderscoreIndex = $logicalName.LastIndexOf('_')
                      if ($lastUnderscoreIndex -gt 0) {
                          $logicalName = $logicalName.Substring(0, $lastUnderscoreIndex) + '.' + $logicalName.Substring($lastUnderscoreIndex + 1)
                      }

                      Write-Host "##[debug]Found semantic model variable: $($item.Name) = $($item.Value)"

                      # Parse the variable name: sm.{name}.{property}
                      $nameParts = $logicalName -split "\."
                   
                      # Skip if the format is incorrect
                      if ($nameParts.Length -ne 3) {
                          Write-Host "##[warning]Invalid semantic model variable format: $($item.Name). Expected format: sm.{name}.{property}"
                          continue
                      }

                      $semanticModelName = $nameParts[1]
                      $propertyName = $nameParts[2]
                      $propertyValue = $item.Value
                   
                      # Initialize the semantic model object if it doesn't exist
                      if (-not $semanticModelGroups.ContainsKey($semanticModelName)) {
                          $semanticModelGroups[$semanticModelName] = @{}
                      }
                   
                      # Add the property to the semantic model
                      $semanticModelGroups[$semanticModelName][$propertyName] = $propertyValue
                  }
              }
           
              # Transform the grouped semantic models into an array of objects
              foreach ($name in $semanticModelGroups.Keys) {
                  $properties = $semanticModelGroups[$name]
               
                  # Only add semantic models that have both required properties
                  if ($properties.ContainsKey("newValue")) {
                      $detailedSemanticModels += [PSCustomObject]@{
                          name = $name
                          newValue = $properties["newValue"]
                      }

                      Write-Host "##[debug]Added semantic model: $name (newValue: $($properties["newValue"]))"
                  }
                  else {
                      Write-Host "##[warning]Semantic model $name is missing required properties (newValue)"
                  }
              }
           
              # Check if any valid semantic models were found
              if ($detailedSemanticModels.Count -eq 0) {
                  Write-Host "##[warning]No valid semantic models found with both oldValue and newValue properties"
              } else {
                  Write-Host "##[debug]Processed $($detailedSemanticModels.Count) valid semantic models"

                  # Convert to JSON
                  $detailedSemanticModelsJson = $detailedSemanticModels | ConvertTo-Json -Depth 5 -Compress

                  if ($detailedSemanticModels.Count -eq 1) {
                    # prepend and append brackets to make it a JSON array
                    $detailedSemanticModelsJson = "[$detailedSemanticModelsJson]"
                  }
                   
                  # Log the JSON for debugging
                  Write-Host "##[debug]Detailed Semantic Models JSON: $detailedSemanticModelsJson"

                  # Set as pipeline variable
                  Write-Host "##vso[task.setvariable variable=FABRIC_SEMANTIC_MODELS_DETAILED]$detailedSemanticModelsJson"
              }
          } catch {
              Write-Error "Error processing semantic model variables: $_"
              Write-Error $_.ScriptStackTrace
              exit 1
          }

    - task: PowerShell@2
      name: prepSemanticModelParameterVars
      displayName: 'Prepare Semantic Model Parameters Updates'
      inputs:
        targetType: 'inline'
        script: |
          try {
              # Initialize empty array for formatted shortcuts
              $detailedSemanticModelsParameters = @()
              $semanticModelParameterGroups = @{}
           
              Write-Host "##[debug]Processing semantic model parameters ..."
           
              # Iterate through all environment variables
              foreach ($item in (Get-Item env:*)) {
                  # Check if it's a semantic model parameter variable (starts with 'smParameter.')

                  if ($item.Name.ToLower().StartsWith('smparameter_')) {
                      $logicalName = $item.Name.ToLower()
                  
                      $logicalName = $logicalName -replace '^smparameter_', 'smparameter.'

                      $lastUnderscoreIndex = $logicalName.LastIndexOf('_')
                      if ($lastUnderscoreIndex -gt 0) {
                          $logicalName = $logicalName.Substring(0, $lastUnderscoreIndex) + '.' + $logicalName.Substring($lastUnderscoreIndex + 1)
                      }

                      Write-Host "##[debug]Found semantic model parameters variable: $($item.Name) = $($item.Value)"

                      # Parse the variable name: smParameter.{name}.{property}
                      $nameParts = $logicalName -split "\."
                   
                      # Skip if the format is incorrect
                      if ($nameParts.Length -ne 3) {
                          Write-Host "##[warning]Invalid semantic model parameter variable format: $($item.Name). Expected format: smParameter.{name}.{property}"
                          continue
                      }

                      $semanticModelParameterName = $nameParts[1]
                      $propertyName = $nameParts[2]
                      $propertyValue = $item.Value
                   
                      # Initialize the semantic model object if it doesn't exist
                      if (-not $semanticModelParameterGroups.ContainsKey($semanticModelParameterName)) {
                          $semanticModelParameterGroups[$semanticModelParameterName] = @{}
                      }
                   
                      # Add the property to the semantic model
                      $semanticModelParameterGroups[$semanticModelParameterName][$propertyName] = $propertyValue
                  }
              }
           
              # Transform the grouped semantic models into an array of objects
              foreach ($name in $semanticModelParameterGroups.Keys) {
                  $properties = $semanticModelParameterGroups[$name]
               
                  # Only add semantic models that have required properties
                  if ($properties.ContainsKey("newValue")) {
                      $detailedSemanticModelsParameters += [PSCustomObject]@{
                          name = $name
                          newValue = $properties["newValue"]
                      }

                      Write-Host "##[debug]Added semantic model parameter: $name (newValue: $($properties["newValue"]))"
                  }
                  else {
                      Write-Host "##[warning]Semantic model parameter $name is missing required properties (newValue)"
                  }
              }
           
              # Check if any valid semantic models parameter were found
              if ($detailedSemanticModelsParameters.Count -eq 0) {
                  Write-Host "##[warning]No valid semantic models found with both oldValue and newValue properties"
              } else {
                  Write-Host "##[debug]Processed $($detailedSemanticModelsParameters.Count) valid semantic models"

                  # Convert to JSON
                  $detailedSemanticModelsParameterJson = $detailedSemanticModelsParameters | ConvertTo-Json -Depth 5 -Compress

                  if ($detailedSemanticModelsParameters.Count -eq 1) {
                    # prepend and append brackets to make it a JSON array
                    $detailedSemanticModelsParameterJson = "[$detailedSemanticModelsParameterJson]"
                  }
                   
                  # Log the JSON for debugging
                  Write-Host "##[debug]Detailed Semantic Models JSON: $detailedSemanticModelsParameterJson"

                  # Set as pipeline variable
                  Write-Host "##vso[task.setvariable variable=FABRIC_SEMANTIC_MODELS_PARAMETER_DETAILED]$detailedSemanticModelsParameterJson"
              }
          } catch {
              Write-Error "Error processing semantic model variables: $_"
              Write-Error $_.ScriptStackTrace
              exit 1
          }

    - task: PowerShell@2
      name: prepManagedConnectionsVars
      displayName: 'Prepare Managed Connections Variables'
      inputs:
        targetType: 'inline'
        script: |
          try {
              # Initialize empty array
              $detailedManagedConnections = @()
              $managedConnectionGroups = @{}
           
              Write-Host "##[debug]Processing managed connection variables from environment..."
           
              # Iterate through all environment variables
              foreach ($item in (Get-Item env:*)) {

                  if ($item.Name.ToLower().StartsWith('mngconnection_')) {
                      $item.Name = $item.Name.ToLower().Replace('mngconnection_', 'managedConnection.').Replace('_', '.')
                  }
                  if ($item.Name -like "managedConnection.*") {
                      Write-Host "##[debug]Found Managed Connection variable: $($item.Name) = $($item.Value)"
                   
                      # Parse the variable name: managedConnection.{name}.{property}
                      $nameParts = $item.Name -split "\."
                   
                      # Skip if the format is incorrect
                      if ($nameParts.Length -ne 3) {
                          Write-Host "##[warning]Invalid managed connection variable format: $($item.Name). Expected format: managedConnection.{name}.{property}"
                          continue
                      }
                   
                      $managedConnectionName = $nameParts[1]
                      $propertyName = $nameParts[2]
                      $propertyValue = $item.Value
                   
                      # Initialize the managed connection object if it doesn't exist
                      if (-not $managedConnectionGroups.ContainsKey($managedConnectionName)) {
                          $managedConnectionGroups[$managedConnectionName] = @{}
                      }
                   
                      # Add the property to the managed connection
                      $managedConnectionGroups[$managedConnectionName][$propertyName] = $propertyValue
                  }
              }

              # Transform the grouped managed connections into an array of objects
              foreach ($name in $managedConnectionGroups.Keys) {
                  $properties = $managedConnectionGroups[$name]

                  $detailedManagedConnections += [PSCustomObject]@{
                        original_name = $properties["original-name"]
                        new_name = $properties["new-name"]
                        guid = $properties["guid"]
                    }

                  Write-Host "##[debug]Added Managed Connection: $name (Original Name: $($properties["original-name"]), New Name: $($properties["new-name"]), GUID: $($properties["guid"]))"
              }

              # Check if any valid managed connections were found
              if ($detailedManagedConnections.Count -eq 0) {
                  Write-Host "##[warning]No valid Managed Connection variables found with both original_name and new_name properties"
              } else {
                  Write-Host "##[debug]Processed $($detailedManagedConnections.Count) valid Managed Connection definitions"

                  # Convert to JSON
                  $detailedManagedConnectionsJson = $detailedManagedConnections | ConvertTo-Json -Depth 5 -Compress

                  if ($detailedManagedConnections.Count -eq 1) {
                    # prepend and append brackets to make it a JSON array
                    $detailedManagedConnectionsJson = "[$detailedManagedConnectionsJson]"
                  }
                   
                  # Log the JSON for debugging
                  Write-Host "##[debug]Detailed Managed Connections JSON: $detailedManagedConnectionsJson"

                  # Set as pipeline variable
                  Write-Host "##vso[task.setvariable variable=FABRIC_MANAGED_CONNECTIONS_DETAILED]$detailedManagedConnectionsJson"
              }
          } catch {
              Write-Error "Error processing Managed Connection variables: $_"
              Write-Error $_.ScriptStackTrace
              exit 1
          }

    - task: PowerShell@2
      inputs:
        targetType: 'inline'
        script: |

          $WorkspaceName = $env:TF_VAR_workspace_names
          $WorkspaceName = $WorkspaceName.Replace('[', '["').Replace(']', '"]').Replace(',', '","') -replace '"\s+', '"'

          $WorkspaceName = $WorkspaceName.Trim('[', ']').Trim('"')
          $scriptPath = "$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts/Create-Workspace.ps1"
          $WorkspaceId = & $scriptPath -WorkspaceName "$WorkspaceName" -CapacityId "$env:TF_VAR_capacity_id"

          Write-Host "##vso[task.setvariable variable=WORKSPACE_ID]$WorkspaceId"
        pwsh: false
        workingDirectory: '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts'
      env:
        ARM_CLIENT_ID: $(ARM_CLIENT_ID)
        ARM_CLIENT_SECRET: $(ARM_CLIENT_SECRET)
        ARM_TENANT_ID: $(ARM_TENANT_ID)
      displayName: 'Fabric Workspace'  

    - task: PowerShell@2
      inputs:
        targetType: 'inline'
        script: |

          $WorkspaceName = $env:TF_VAR_workspace_names
          $WorkspaceName = $WorkspaceName.Replace('[', '["').Replace(']', '"]').Replace(',', '","') -replace '"\s+', '"'

          $WorkspaceName = $WorkspaceName.Trim('[', ']').Trim('"')
          $scriptPath = "$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts/Fabric-FolderSynchronization.ps1"
          $folderHierarchyJson = & $scriptPath -WorkspaceName "$WorkspaceName"

          # display folder hierarchy for debugging
          Write-Host "##[debug]Folder Hierarchy: $folderHierarchyJson"

          Write-Host "##vso[task.setvariable variable=FOLDER_HIERARCHY]$folderHierarchyJson"

        pwsh: false
        workingDirectory: '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts'
      env:
        ARM_CLIENT_ID: $(ARM_CLIENT_ID)
        ARM_CLIENT_SECRET: $(ARM_CLIENT_SECRET)
        ARM_TENANT_ID: $(ARM_TENANT_ID)
      displayName: 'Fabric Folder Synchronization'  

    - task: PowerShell@2
      inputs:
        targetType: 'inline'
        script: |
          try {
              Write-Host "##[section]Creating Fabric Environment"
             
              # Parse workspace configuration
              $WorkspaceName = $env:TF_VAR_workspace_names
              $WorkspaceName = $WorkspaceName.Replace('[', '["').Replace(']', '"]').Replace(',', '","') -replace '"\s+', '"'
              $WorkspaceName = $WorkspaceName.Trim('[', ']').Trim('"')
             
              # Get workspace ID from previous step
              $WorkspaceId = $env:WORKSPACE_ID
             
              # Parse spark compute settings
              $sparkComputeJson = $env:FABRIC_SPARK_COMPUTE
              Write-Host "##[debug]Spark Compute JSON: $sparkComputeJson"
             
              if ([string]::IsNullOrEmpty($sparkComputeJson) -or $sparkComputeJson -eq '{}') {
                  Write-Host "##[warning]No spark compute configuration found, skipping environment creation"
                  Write-Host "##vso[task.setvariable variable=ENVIRONMENT_ID]"
                  Write-Host "##vso[task.setvariable variable=MAIN_ENVIRONMENT_MAPPING]{}"
                  return
              }
             
              $sparkSettings = ConvertFrom-Json $sparkComputeJson
              Write-Host "##[debug]Parsed Spark Settings: $($sparkSettings | ConvertTo-Json -Depth 3)"
             
              # Find environment platform file
              $srcFabricPath = "$(System.DefaultWorkingDirectory)/src/fabric"
              $platformFiles = Get-ChildItem -Path $srcFabricPath -Recurse -Filter ".platform" | Where-Object {
                  $_.Directory.Name -like "*den_env_pdi_001_spark_runtime_environment.Environment*"
              }
             
              if ($platformFiles.Count -eq 0) {
                  Write-Host "##[warning]No environment platform file found, skipping environment creation"
                  Write-Host "##vso[task.setvariable variable=ENVIRONMENT_ID]"
                  Write-Host "##vso[task.setvariable variable=MAIN_ENVIRONMENT_MAPPING]{}"
                  return
              }
             
              # Read platform file
              $platformFile = $platformFiles[0]
              $platformContent = Get-Content $platformFile.FullName -Raw | ConvertFrom-Json
              $environmentDisplayName = $platformContent.metadata.displayName
              $environmentLogicalId = $platformContent.config.logicalId
              $fullPath = $platformFile.Directory.FullName
              $folderPath = $fullPath -replace '.*src[/\\]fabric[/\\]', ''

              Write-Host "##[debug]Environment Display Name: $environmentDisplayName"
              Write-Host "##[debug]Environment Logical ID: $environmentLogicalId"
              Write-Host "##[debug]Folder Path: $folderPath"
             
              # Create environment using PowerShell script
              $scriptPath = "$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts/Invoke-EnvironmentManagement.ps1"
              $folderHierarchy = if ([string]::IsNullOrEmpty($env:FOLDER_HIERARCHY)) { $null } else { $env:FOLDER_HIERARCHY }
             
              $environmentResult = & $scriptPath -Action 'CreateOrUpdate' -WorkspaceId $WorkspaceId -DisplayName $environmentDisplayName -FolderHierarchy $folderHierarchy -FolderPath $folderPath

              if ($environmentResult) {

                  # Handle different result structures
                  $firstResult = $null

                  if ($environmentResult -is [array]) {
                      $firstResult = $environmentResult[0]
                  } else {
                      $firstResult = $environmentResult
                  }

                  Write-Host "##[debug]Environment Creation Result: $($firstResult | ConvertTo-Json -Depth 10 -Compress)"

                  try {
                      $parsedResult = $null
                    
                      # Try to parse as JSON if it's a string
                      if ($firstResult -is [string]) {
                          $parsedResult = $firstResult | ConvertFrom-Json
                      }
                      # If it's already an object, use it directly
                      elseif ($firstResult -is [PSCustomObject]) {
                          $parsedResult = $firstResult
                      }
                      else {
                          throw "Unable to parse result: unexpected type $($firstResult.GetType().FullName)"
                      }
                    
                      # Now handle the parsed result structure
                      if ($parsedResult.PSObject.Properties['value'] -and $parsedResult.value -is [array]) {
                          Write-Host "##[debug]Result contains 'value' array with $($parsedResult.value.Count) items"

                          # Find the Environment item
                          $environmentItem =  $parsedResult.value | Where-Object { $_.id } | Select-Object -First 1

                          if ($environmentItem) {
                              $environmentId = $environmentItem.id.Trim()
                              Write-Host "##[debug]Extracted Environment ID: $environmentId"
                          } else {
                              throw "No Environment item found in result array"
                          }
                      }
                      # Handle direct object result
                      elseif ($parsedResult.PSObject.Properties['id']) {
                          $environmentId = $parsedResult.id.Trim()
                          Write-Host "##[debug]Extracted Environment ID from direct result: $environmentId"
                      }
                      else {
                          throw "Unable to extract ID from result structure"
                      }
                    
                  }
                  catch {
                      Write-Host "##[error]Error extracting environment ID: $($_.Exception.Message)"
                      Write-Host "##[debug]Raw firstResult type: $($firstResult.GetType().FullName)"
                      Write-Host "##[debug]Raw firstResult content: $firstResult"
                    
                      # Additional debugging for PSCustomObject
                      if ($firstResult -is [PSCustomObject]) {
                          Write-Host "##[debug]PSCustomObject properties:"
                          $firstResult.PSObject.Properties | ForEach-Object {
                              Write-Host "##[debug]  - $($_.Name): $($_.Value)"
                          }
                        
                          if ($firstResult.PSObject.Properties['value']) {
                              Write-Host "##[debug]Value property type: $($firstResult.value.GetType().FullName)"
                              if ($firstResult.value -is [array]) {
                                  Write-Host "##[debug]Value array contents:"
                                  for ($i = 0; $i -lt $firstResult.value.Count; $i++) {
                                      Write-Host "##[debug]  [$i]: $($firstResult.value[$i] | ConvertTo-Json -Compress)"
                                  }
                              }
                          }
                      }

                      throw "Failed to extract environment ID from creation result"
                  }

                  # Create logical ID to environment ID mapping
                  $mainEnvironmentMapping = @{
                      $environmentLogicalId = $environmentId
                  }
                  $mainEnvironmentMappingJson = $mainEnvironmentMapping | ConvertTo-Json -Compress
                 
                  Write-Host "##[debug]Environment created successfully with ID: $environmentId"
                  Write-Host "##[debug]Main Environment Mapping: LogicalId=$environmentLogicalId -> EnvironmentId=$environmentId"
                 
                  # Set pipeline variables
                  Write-Host "##vso[task.setvariable variable=ENVIRONMENT_ID]$environmentId"
                  Write-Host "##vso[task.setvariable variable=MAIN_ENVIRONMENT_MAPPING]$mainEnvironmentMappingJson"
                 
                  # Configure Spark settings for the environment
                  Write-Host "##[section]Configuring Spark Environment Settings"
                 
                  $sparkScriptPath = "$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts/Invoke-SparkEnvironmentSettings.ps1"
                 
                  & $sparkScriptPath -WorkspaceId $WorkspaceId -EnvironmentName $environmentDisplayName -DriverCores $sparkSettings.driver_cores -DriverMemory $sparkSettings.driver_memory -ExecutorCores $sparkSettings.executor_cores -ExecutorMemory $sparkSettings.executor_memory -RuntimeVersion $sparkSettings.runtime_version -MinExecutors $sparkSettings.min_executors -MaxExecutors $sparkSettings.max_executors
                 
                  Write-Host "##[section]Spark settings configured successfully"
              } else {
                  Write-Host "##vso[task.LogIssue type=error;]Failed to create environment"
                  Write-Host "##vso[task.complete result=Failed;]"
                  exit 1
              }
             
          } catch {
              Write-Host "##vso[task.LogIssue type=error;]Error creating environment: $($_.Exception.Message)"
              Write-Host "##vso[task.LogIssue type=error;]Stack Trace: $($_.ScriptStackTrace)"
              Write-Host "##vso[task.complete result=Failed;]"
              exit 1
          }
        pwsh: false
        workingDirectory: '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts'
      env:
        ARM_CLIENT_ID: $(ARM_CLIENT_ID)
        ARM_CLIENT_SECRET: $(ARM_CLIENT_SECRET)
        ARM_TENANT_ID: $(ARM_TENANT_ID)
      displayName: 'Create Fabric Environment and Configure Spark Settings'

    - task: PowerShell@2
      inputs:
        targetType: 'inline'
        script: |
          try {
              Write-Host "##[section]Creating Fabric Subdomain Environments"
             
              # Parse workspace configuration
              $WorkspaceName = $env:TF_VAR_workspace_names
              $WorkspaceName = $WorkspaceName.Replace('[', '["').Replace(']', '"]').Replace(',', '","') -replace '"\s+', '"'
              $WorkspaceName = $WorkspaceName.Trim('[', ']').Trim('"')
             
              # Get workspace ID from previous step
              $WorkspaceId = $env:WORKSPACE_ID
             
              # Parse spark compute settings
              $sparkComputeJson = $env:FABRIC_SPARK_COMPUTE
              Write-Host "##[debug]Spark Compute JSON: $sparkComputeJson"
             
              if ([string]::IsNullOrEmpty($sparkComputeJson) -or $sparkComputeJson -eq '{}') {
                  Write-Host "##[warning]No spark compute configuration found, skipping subdomain environment creation"
                  Write-Host "##vso[task.setvariable variable=SUBDOMAIN_ENVIRONMENT_MAPPING]{}"
                  return
              }
             
              $sparkSettings = ConvertFrom-Json $sparkComputeJson
              Write-Host "##[debug]Parsed Spark Settings: $($sparkSettings | ConvertTo-Json -Depth 3)"
             
              # Find subdomain environment platform files (excluding main runtime environment)
              $srcFabricPath = "$(System.DefaultWorkingDirectory)/src/fabric"
              $platformFiles = Get-ChildItem -Path $srcFabricPath -Recurse -Filter ".platform" | Where-Object {
                  $_.Directory.Name -like "*.Environment" -and
                  $_.Directory.Name -notlike "*den_env_pdi_001_spark_runtime_environment.Environment*"
              }
             
              if ($platformFiles.Count -eq 0) {
                  Write-Host "##[warning]No subdomain environment platform files found, skipping subdomain environment creation"
                  Write-Host "##vso[task.setvariable variable=SUBDOMAIN_ENVIRONMENT_MAPPING]{}"
                  return
              }
             
              Write-Host "##[debug]Found $($platformFiles.Count) subdomain environment platform files"
             
              # Create environments for each platform file found
              $createdEnvironments = @()
              $subdomainEnvironmentMapping = @{}
             
              foreach ($platformFile in $platformFiles) {
                  try {
                      # Read platform file
                      $platformContent = Get-Content $platformFile.FullName -Raw | ConvertFrom-Json
                      $environmentDisplayName = $platformContent.metadata.displayName
                      $environmentLogicalId = $platformContent.config.logicalId
                      $fullPath = $platformFile.Directory.FullName
                      $folderPath = $fullPath -replace '.*src[/\\]fabric[/\\]', ''

                      Write-Host "##[debug]Processing Subdomain Environment:"
                      Write-Host "##[debug]  Display Name: $environmentDisplayName"
                      Write-Host "##[debug]  Logical ID: $environmentLogicalId"
                      Write-Host "##[debug]  Folder Path: $folderPath"
                     
                      # Create environment using PowerShell script
                      $scriptPath = "$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts/Invoke-EnvironmentManagement.ps1"
                      $folderHierarchy = if ([string]::IsNullOrEmpty($env:FOLDER_HIERARCHY)) { $null } else { $env:FOLDER_HIERARCHY }
                     
                      $environmentResult = & $scriptPath -Action 'CreateOrUpdate' -WorkspaceId $WorkspaceId -DisplayName $environmentDisplayName -FolderHierarchy $folderHierarchy -FolderPath $folderPath
                     
                      if ($environmentResult) {
                          # Handle different result structures
                          $firstResult = $null
                        
                          if ($environmentResult -is [array]) {
                              $firstResult = $environmentResult[0]
                          } else {
                              $firstResult = $environmentResult
                          }
                        
                          Write-Host "##[debug]Environment Creation Result: $($firstResult | ConvertTo-Json -Depth 10 -Compress)"

                          try {
                              $parsedResult = $null
                            
                              # Try to parse as JSON if it's a string
                              if ($firstResult -is [string]) {
                                  $parsedResult = $firstResult | ConvertFrom-Json
                              }
                              # If it's already an object, use it directly
                              elseif ($firstResult -is [PSCustomObject]) {
                                  $parsedResult = $firstResult
                              }
                              else {
                                  throw "Unable to parse result: unexpected type $($firstResult.GetType().FullName)"
                              }
                            
                              # Now handle the parsed result structure
                              if ($parsedResult.PSObject.Properties['value'] -and $parsedResult.value -is [array]) {
                                  Write-Host "##[debug]Result contains 'value' array with $($parsedResult.value.Count) items"

                                  # Find the Environment item
                                  $environmentItem =  $parsedResult.value | Where-Object { $_.id } | Select-Object -First 1

                                  if ($environmentItem) {
                                      $environmentId = $environmentItem.id.Trim()
                                      Write-Host "##[debug]Extracted Environment ID: $environmentId"
                                  } else {
                                      throw "No Environment item found in result array"
                                  }
                              }
                              # Handle direct object result
                              elseif ($parsedResult.PSObject.Properties['id']) {
                                  $environmentId = $parsedResult.id.Trim()
                                  Write-Host "##[debug]Extracted Environment ID from direct result: $environmentId"
                              }
                              else {
                                  throw "Unable to extract ID from result structure"
                              }
                            
                          }
                          catch {
                              Write-Host "##[error]Error extracting environment ID: $($_.Exception.Message)"
                              Write-Host "##[debug]Raw firstResult type: $($firstResult.GetType().FullName)"
                              Write-Host "##[debug]Raw firstResult content: $firstResult"
                            
                              # Additional debugging for PSCustomObject
                              if ($firstResult -is [PSCustomObject]) {
                                  Write-Host "##[debug]PSCustomObject properties:"
                                  $firstResult.PSObject.Properties | ForEach-Object {
                                      Write-Host "##[debug]  - $($_.Name): $($_.Value)"
                                  }
                                
                                  if ($firstResult.PSObject.Properties['value']) {
                                      Write-Host "##[debug]Value property type: $($firstResult.value.GetType().FullName)"
                                      if ($firstResult.value -is [array]) {
                                          Write-Host "##[debug]Value array contents:"
                                          for ($i = 0; $i -lt $firstResult.value.Count; $i++) {
                                              Write-Host "##[debug]  [$i]: $($firstResult.value[$i] | ConvertTo-Json -Compress)"
                                          }
                                      }
                                  }
                              }

                              throw "Failed to extract environment ID from creation result"
                          }

                         
                          # Add to logical ID mapping
                          $subdomainEnvironmentMapping[$environmentLogicalId] = $environmentId
                         
                          Write-Host "##[debug]Subdomain Environment '$environmentDisplayName' created successfully with ID: $environmentId"
                          Write-Host "##[debug]Subdomain Environment Mapping: LogicalId=$environmentLogicalId -> EnvironmentId=$environmentId"
                         
                          # Store environment info for spark configuration
                          $createdEnvironments += @{
                              DisplayName = $environmentDisplayName
                              EnvironmentId = $environmentId
                              LogicalId = $environmentLogicalId
                              WorkspaceId = $WorkspaceId
                          }
                         
                      } else {
                          Write-Host "##vso[task.LogIssue type=warning;]Failed to create subdomain environment: $environmentDisplayName"
                      }
                     
                  } catch {
                      Write-Host "##vso[task.LogIssue type=error;]Error processing subdomain environment '$($platformFile.Name)': $($_.Exception.Message)"
                      Write-Host "##[debug]Stack Trace: $($_.ScriptStackTrace)"
                      continue
                  }
              }
             
              # Export subdomain environment mapping as JSON
              $subdomainEnvironmentMappingJson = $subdomainEnvironmentMapping | ConvertTo-Json -Compress
              Write-Host "##[debug]Subdomain Environment Mappings: $subdomainEnvironmentMappingJson"
              Write-Host "##vso[task.setvariable variable=SUBDOMAIN_ENVIRONMENT_MAPPING]$subdomainEnvironmentMappingJson"
             
              # Configure Spark settings for all created subdomain environments
              if ($createdEnvironments.Count -gt 0) {
                  Write-Host "##[section]Configuring Spark Settings for Subdomain Environments"
                 
                  $sparkScriptPath = "$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts/Invoke-SparkEnvironmentSettings.ps1"
                 
                  foreach ($env in $createdEnvironments) {
                      try {
                          Write-Host "##[debug]Configuring Spark settings for: $($env.DisplayName)"
                         
                          & $sparkScriptPath -WorkspaceId $env.WorkspaceId -EnvironmentName $env.DisplayName -DriverCores $sparkSettings.driver_cores -DriverMemory $sparkSettings.driver_memory -ExecutorCores $sparkSettings.executor_cores -ExecutorMemory $sparkSettings.executor_memory -RuntimeVersion $sparkSettings.runtime_version -MinExecutors $sparkSettings.min_executors -MaxExecutors $sparkSettings.max_executors
                         
                          Write-Host "##[debug]Spark settings configured successfully for: $($env.DisplayName)"
                      } catch {
                          Write-Host "##vso[task.LogIssue type=warning;]Failed to configure Spark settings for '$($env.DisplayName)': $($_.Exception.Message)"
                          continue
                      }
                  }
                 
                  Write-Host "##[section]Subdomain Environment Spark settings configuration completed"
              }
             
              Write-Host "##[section]Subdomain Environment creation process completed. Created $($createdEnvironments.Count) environments."
             
          } catch {
              Write-Host "##vso[task.LogIssue type=error;]Error creating subdomain environments: $($_.Exception.Message)"
              Write-Host "##vso[task.LogIssue type=error;]Stack Trace: $($_.ScriptStackTrace)"
              Write-Host "##vso[task.complete result=Failed;]"
              exit 1
          }
        pwsh: false
        workingDirectory: '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts'
      env:
        ARM_CLIENT_ID: $(ARM_CLIENT_ID)
        ARM_CLIENT_SECRET: $(ARM_CLIENT_SECRET)
        ARM_TENANT_ID: $(ARM_TENANT_ID)
      displayName: 'Create Fabric Subdomain Environments and Configure Spark Settings'

    - task: PowerShell@2
      inputs:
        targetType: 'inline'
        script: |
          try {
              Write-Host "##[section]Creating Fabric Lakehouses"
             
              # Parse workspace configuration
              $WorkspaceName = $env:TF_VAR_workspace_names
              $WorkspaceName = $WorkspaceName.Replace('[', '["').Replace(']', '"]').Replace(',', '","') -replace '"\s+', '"'
              $WorkspaceName = $WorkspaceName.Trim('[', ']').Trim('"')
             
              # Get workspace ID from previous step
              $WorkspaceId = $env:WORKSPACE_ID
             
              # Find lakehouse platform files (excluding filtered ones)
              $srcFabricPath = "$(System.DefaultWorkingDirectory)/src/fabric"
              $platformFiles = Get-ChildItem -Path $srcFabricPath -Recurse -Filter ".platform" | Where-Object {
                  $_.Directory.Name -like "*.Lakehouse" -and
                  $_.Directory.Name -notlike "*den_lhw_pdi_001_curated.Lakehouse*" -and
                  $_.Directory.Name -notlike "*den_lhw_pdi_001_raw.Lakehouse*"
              }
             
              if ($platformFiles.Count -eq 0) {
                  Write-Host "##[warning]No lakehouse platform files found, skipping lakehouse creation"
                  return
              }
             
              Write-Host "##[debug]Found $($platformFiles.Count) lakehouse platform files"
             
              # Create lakehouses for each platform file found
              $createdLakehouses = @()
             
              foreach ($platformFile in $platformFiles) {
                  try {
                      # Read platform file
                      $platformContent = Get-Content $platformFile.FullName -Raw | ConvertFrom-Json
                      $lakehouseDisplayName = $platformContent.metadata.displayName
                      $fullPath = $platformFile.Directory.FullName
                      $folderPath = $fullPath -replace '.*src[/\\]fabric[/\\]', ''

                      Write-Host "##[debug]Processing Lakehouse:"
                      Write-Host "##[debug]  Display Name: $lakehouseDisplayName"
                      Write-Host "##[debug]  Folder Path: $folderPath"
                     
                      # Create lakehouse using PowerShell script
                      $scriptPath = "$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts/Invoke-LakehouseManagement.ps1"
                      $folderHierarchy = if ([string]::IsNullOrEmpty($env:FOLDER_HIERARCHY)) { $null } else { $env:FOLDER_HIERARCHY }
                     
                      $lakehouseResult = & $scriptPath -Action 'CreateOrUpdate' -WorkspaceId $WorkspaceId -DisplayName $lakehouseDisplayName -FolderHierarchy $folderHierarchy -FolderPath $folderPath
                     
                      if ($lakehouseResult) {
                          # Handle different result structures
                          $firstResult = $null
                        
                          if ($lakehouseResult -is [array]) {
                              $firstResult = $lakehouseResult[0]
                          } else {
                              $firstResult = $lakehouseResult
                          }
                          
                          Write-Host "##[debug]Lakehouse Creation Result: $($firstResult | ConvertTo-Json -Depth 10 -Compress)"
   
                          try {
                              $parsedResult = $null
                            
                              # Try to parse as JSON if it's a string
                              if ($firstResult -is [string]) {
                                  $parsedResult = $firstResult | ConvertFrom-Json
                              }
                              # If it's already an object, use it directly
                              elseif ($firstResult -is [PSCustomObject]) {
                                  $parsedResult = $firstResult
                              }
                              else {
                                  throw "Unable to parse result: unexpected type $($firstResult.GetType().FullName)"
                              }
                            
                              # Now handle the parsed result structure
                              if ($parsedResult.PSObject.Properties['value'] -and $parsedResult.value -is [array]) {
                                  Write-Host "##[debug]Result contains 'value' array with $($parsedResult.value.Count) items"
                                
                                  # Find the Lakehouse item
                                  $lakehouseItem =  $parsedResult.value | Where-Object { $_.id } | Select-Object -First 1
                                
                                  if ($lakehouseItem) {
                                      $lakehouseId = $lakehouseItem.id.Trim()
                                      Write-Host "##[debug]Extracted Lakehouse ID: $lakehouseId"
                                  } else {
                                      throw "No Lakehouse item found in result array"
                                  }
                              }
                              # Handle direct object result
                              elseif ($parsedResult.PSObject.Properties['id']) {
                                  $lakehouseId = $parsedResult.id.Trim()
                                  Write-Host "##[debug]Extracted Lakehouse ID from direct result: $lakehouseId"
                              }
                              else {
                                  throw "Unable to extract ID from result structure"
                              }
                            
                          }
                          catch {
                              Write-Host "##[error]Error extracting lakehouse ID: $($_.Exception.Message)"
                              Write-Host "##[debug]Raw firstResult type: $($firstResult.GetType().FullName)"
                              Write-Host "##[debug]Raw firstResult content: $firstResult"
                            
                              # Additional debugging for PSCustomObject
                              if ($firstResult -is [PSCustomObject]) {
                                  Write-Host "##[debug]PSCustomObject properties:"
                                  $firstResult.PSObject.Properties | ForEach-Object {
                                      Write-Host "##[debug]  - $($_.Name): $($_.Value)"
                                  }
                                
                                  if ($firstResult.PSObject.Properties['value']) {
                                      Write-Host "##[debug]Value property type: $($firstResult.value.GetType().FullName)"
                                      if ($firstResult.value -is [array]) {
                                          Write-Host "##[debug]Value array contents:"
                                          for ($i = 0; $i -lt $firstResult.value.Count; $i++) {
                                              Write-Host "##[debug]  [$i]: $($firstResult.value[$i] | ConvertTo-Json -Compress)"
                                          }
                                      }
                                  }
                              }
                            
                              throw "Failed to extract lakehouse ID from creation result"
                          }
                                                
                          # Create the key for file naming (similar to Terraform's each.key)
                          $fileKey = "${WorkspaceName}-${lakehouseDisplayName}"
                          $safeFileKey = $fileKey.Replace("-", "_").Replace(" ", "_").Replace("/", "_")
                         
                          # Create .terraform directory if it doesn't exist
                          $terraformDir = "$(workingDirectory)/.terraform"
                          if (!(Test-Path $terraformDir)) {
                              New-Item -ItemType Directory -Path $terraformDir -Force
                          }
                         
                          # Save lakehouse ID to file (same format as Terraform was using)
                          $lakehouseIdFile = "$terraformDir/lakehouse_${safeFileKey}_id.txt"
                          Set-Content -Path $lakehouseIdFile -Value $lakehouseId -NoNewline -Force
                         
                          Write-Host "##[debug]Lakehouse '$lakehouseDisplayName' created successfully with ID: $lakehouseId"
                          Write-Host "##[debug]Lakehouse ID saved to: $lakehouseIdFile"
                         
                          # Store lakehouse info for downstream processes
                          $createdLakehouses += @{
                              DisplayName = $lakehouseDisplayName
                              LakehouseId = $lakehouseId
                              WorkspaceId = $WorkspaceId
                              FolderPath = $folderPath
                              FileKey = $safeFileKey
                          }
                         
                      } else {
                          Write-Host "##vso[task.LogIssue type=warning;]Failed to create lakehouse: $lakehouseDisplayName"
                      }
                     
                  } catch {
                      Write-Host "##vso[task.LogIssue type=error;]Error processing lakehouse $($platformFile.Name) : $($_.Exception.Message)"
                      Write-Host "##[debug]Stack Trace: $($_.ScriptStackTrace)"
                      continue
                  }
              }
             
              Write-Host "##[debug]Lakehouse creation process completed. Created $($createdLakehouses.Count) lakehouses."
             
              # Create a summary of created lakehouses for pipeline variables
              if ($createdLakehouses.Count -gt 0) {
                  $lakehouseSummary = $createdLakehouses | ConvertTo-Json -Compress
                  Write-Host "##[debug]Created Lakehouses Summary: $lakehouseSummary"
                  Write-Host "##vso[task.setvariable variable=CREATED_LAKEHOUSES]$lakehouseSummary"
                 
                  # Create a comma-separated list of lakehouse names for shortcuts processing
                  $lakehouseNames = ($createdLakehouses | ForEach-Object { $_.DisplayName }) -join ", "
                  Write-Host "##vso[task.setvariable variable=LAKEHOUSE_NAMES]$lakehouseNames"
              } else {
                  Write-Host "##vso[task.setvariable variable=CREATED_LAKEHOUSES][]"
                  Write-Host "##vso[task.setvariable variable=LAKEHOUSE_NAMES]"
              }
             
          } catch {
              Write-Host "##vso[task.LogIssue type=error;]Error creating lakehouses: $($_.Exception.Message)"
              Write-Host "##vso[task.LogIssue type=error;]Stack Trace: $($_.ScriptStackTrace)"
              Write-Host "##vso[task.complete result=Failed;]"
              exit 1
          }
        pwsh: false
        workingDirectory: '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts'
      env:
        ARM_CLIENT_ID: $(ARM_CLIENT_ID)
        ARM_CLIENT_SECRET: $(ARM_CLIENT_SECRET)
        ARM_TENANT_ID: $(ARM_TENANT_ID)
      displayName: 'Create Fabric Lakehouses'

    - task: PowerShell@2
      inputs:
        targetType: 'inline'
        script: |
          try {
              Write-Host "##[section]Creating and Updating Fabric Notebooks"
             
              # Parse workspace configuration
              $WorkspaceName = $env:TF_VAR_workspace_names
              $WorkspaceName = $WorkspaceName.Replace('[', '["').Replace(']', '"]').Replace(',', '","') -replace '"\s+', '"'
              $WorkspaceName = $WorkspaceName.Trim('[', ']').Trim('"')
             
              # Get workspace ID and main environment ID from previous steps
              # ENVIRONMENT_ID comes from the main Python runtime environment created earlier
              # This corresponds to the environment_ids output in Terraform
              $WorkspaceId = $env:WORKSPACE_ID
              $MainEnvironmentId = $env:ENVIRONMENT_ID  # This is the Python runtime environment
             
              # Parse environment mappings from previous steps
              $mainEnvironmentMapping = @{}
              $subdomainEnvironmentMapping = @{}
             
              if (![string]::IsNullOrEmpty($env:MAIN_ENVIRONMENT_MAPPING) -and $env:MAIN_ENVIRONMENT_MAPPING -ne '{}') {
                  $mainEnvironmentMapping = ConvertFrom-Json $env:MAIN_ENVIRONMENT_MAPPING
                  Write-Host "##[debug]Main Environment Mapping loaded: $($mainEnvironmentMapping | ConvertTo-Json -Compress)"
              }
             
              if (![string]::IsNullOrEmpty($env:SUBDOMAIN_ENVIRONMENT_MAPPING) -and $env:SUBDOMAIN_ENVIRONMENT_MAPPING -ne '{}') {
                  $subdomainEnvironmentMapping = ConvertFrom-Json $env:SUBDOMAIN_ENVIRONMENT_MAPPING
                  Write-Host "##[debug]Subdomain Environment Mapping loaded: $($subdomainEnvironmentMapping | ConvertTo-Json -Compress)"
              }
             
              Write-Host "##[debug]Available Environment Logical IDs:"
              Write-Host "##[debug]  Main Environment Logical IDs: $($mainEnvironmentMapping.PSObject.Properties.Name -join ', ')"
              Write-Host "##[debug]  Subdomain Environment Logical IDs: $($subdomainEnvironmentMapping.PSObject.Properties.Name -join ', ')"
             
              # Parse created lakehouses for lakehouse ID lookup
              $createdLakehouses = @{}
              if (![string]::IsNullOrEmpty($env:CREATED_LAKEHOUSES) -and $env:CREATED_LAKEHOUSES -ne '[]') {
                  $lakehouseArray = ConvertFrom-Json $env:CREATED_LAKEHOUSES
                  foreach ($lh in $lakehouseArray) {
                      $createdLakehouses[$lh.DisplayName] = $lh.LakehouseId
                  }
              }
              Write-Host "##[debug]Available Lakehouses: $($createdLakehouses.Keys -join ', ')"
             
              # Build Ellie platform files list (equivalent to local.ellie_platform_files)
              $excludedNotebooks = @()
              $elliePlatformFiles = @()
             
              $ellieBasePath = "$(System.DefaultWorkingDirectory)/src/ellie"
              if (Test-Path $ellieBasePath) {
                  Write-Host "##[debug]Checking for Ellie platform files in: $ellieBasePath"
                 
                  $elliePlatformFilesList = Get-ChildItem -Path $ellieBasePath -Recurse -Filter "*.platform" | Where-Object {
                      $_.Directory.Name -like "*.Notebook"
                  }
                 
                  foreach ($platformFile in $elliePlatformFilesList) {
                      try {
                          $platformContent = Get-Content $platformFile.FullName -Raw | ConvertFrom-Json
                          $displayName = $platformContent.metadata.displayName
                          $excludeEntry = "${displayName}.Notebook"
                          $elliePlatformFiles += $excludeEntry
                          Write-Host "##[debug]Found Ellie platform file: $excludeEntry"
                      } catch {
                          Write-Host "##[warning]Could not parse Ellie platform file: $($platformFile.FullName)"
                          continue
                      }
                  }
              }
             
              $excludedNotebooks = $elliePlatformFiles
              Write-Host "##[debug]Excluded Notebooks (from Ellie): $($excludedNotebooks -join ', ')"
             
              # Find notebook platform files (excluding filtered ones)
              $srcFabricPath = "$(System.DefaultWorkingDirectory)/src/fabric"
              $platformFiles = Get-ChildItem -Path $srcFabricPath -Recurse -Filter ".platform" | Where-Object {
                  $_.Directory.Name -like "*.Notebook" -and
                  $excludedNotebooks -notcontains $_.Directory.Parent.Name
              }
             
              if ($platformFiles.Count -eq 0) {
                  Write-Host "##[warning]No notebook platform files found, skipping notebook creation"
                  return
              }
             
              Write-Host "##[debug]Found $($platformFiles.Count) notebook platform files"
             
              # Process notebooks in two phases: 1) Update dependencies, 2) Create/Update notebooks
              $notebookConfigs = @()
             
              # Phase 1: Collect and process notebook configurations
              foreach ($platformFile in $platformFiles) {
                  try {
                      # Read platform file
                      $platformContent = Get-Content $platformFile.FullName -Raw | ConvertFrom-Json
                      $notebookDisplayName = $platformContent.metadata.displayName

                      $fullPath = $platformFile.Directory.FullName
                      $folderPath = $fullPath -replace '.*src[/\\]fabric[/\\]', ''

                      $notebookDir = $platformFile.Directory.FullName
                     
                      # Find content file (prioritize .py, then .scala, then .sql)
                      $contentFile = $null
                      $ipynbFile = Join-Path $notebookDir "notebook-content.ipynb"
                     
                      @("notebook-content.py", "notebook-content.scala", "notebook-content.sql") | ForEach-Object {
                          $testFile = Join-Path $notebookDir $_
                          if ((Test-Path $testFile) -and ($null -eq $contentFile)) {
                              $contentFile = $testFile
                          }
                      }
                     
                      # Default to .py if no content file found
                      if ($null -eq $contentFile) {
                          $contentFile = Join-Path $notebookDir "notebook-content.py"
                      }
                     
                      Write-Host "##[debug]Processing Notebook:"
                      Write-Host "##[debug]  Display Name: $notebookDisplayName"
                      Write-Host "##[debug]  Folder Path: $folderPath"
                      Write-Host "##[debug]  Content File: $contentFile"
                      Write-Host "##[debug]  IPYNB File: $ipynbFile"
                     
                      # Extract metadata from notebook content
                      $lakehouseName = "null"
                      $environmentId = "null"
                     
                      if (Test-Path $contentFile) {
                          $content = Get-Content $contentFile -Raw
                         
                          # Extract lakehouse name
                          if ($content -match '(?m)^\s*# META\s+"default_lakehouse_name":\s*"([^"]+)"') {
                              $lakehouseName = $matches[1]
                          } elseif ($content -match '(?m)^\s*-- META\s+"default_lakehouse_name":\s*"([^"]+)"') {
                              $lakehouseName = $matches[1]
                          }
                         
                          # Extract environment ID
                          if ($content -match '(?m)^\s*# META\s+"environmentId":\s*"([^"]+)"') {
                              $environmentId = $matches[1]
                          } elseif ($content -match '(?m)^\s*-- META\s+"environmentId":\s*"([^"]+)"') {
                              $environmentId = $matches[1]
                          }
                      }
                     
                      # Resolve lakehouse ID
                      $lakehouseId = $null
                      if ($lakehouseName -ne "null" -and $createdLakehouses.ContainsKey($lakehouseName)) {
                          $lakehouseId = $createdLakehouses[$lakehouseName]
                      }
                     
                      if ($environmentId -ne "null") {
                          # Try to find matching property name in both mappings
                          $foundMatch = $false
                        
                          # First, iterate through main environment mapping property names
                          if ($mainEnvironmentMapping -and $mainEnvironmentMapping.PSObject.Properties.Count -gt 0) {
                              foreach ($propertyName in $mainEnvironmentMapping.PSObject.Properties.Name) {
                                  if ($environmentId -eq $propertyName) {
                                      $resolvedEnvironmentId = $mainEnvironmentMapping.$propertyName
                                      $foundMatch = $true
                                      Write-Host "##[debug]Found match in main environment mapping: Property='$propertyName' -> Value='$resolvedEnvironmentId'"
                                      break
                                  }
                              }
                          }
                        
                          # If not found in main mapping, iterate through subdomain environment mapping property names
                          if (-not $foundMatch -and $subdomainEnvironmentMapping -and $subdomainEnvironmentMapping.PSObject.Properties.Count -gt 0) {
                              foreach ($propertyName in $subdomainEnvironmentMapping.PSObject.Properties.Name) {
                                  if ($environmentId -eq $propertyName) {
                                      $resolvedEnvironmentId = $subdomainEnvironmentMapping.$propertyName
                                      $foundMatch = $true
                                      Write-Host "##[debug]Found match in subdomain environment mapping: Property='$propertyName' -> Value='$resolvedEnvironmentId'"
                                      break
                                  }
                              }
                          }
                      }
                      if ([string]::IsNullOrEmpty($resolvedEnvironmentId)) {
                          $resolvedEnvironmentId = "00000000-0000-0000-0000-000000000000"
                      }
                     
                      # The EnvironmentIdPython should always be the main Python runtime environment
                      $environmentIdPython = $env:ENVIRONMENT_ID
                     
                      # Store notebook configuration
                      $notebookConfigs += @{
                          DisplayName = $notebookDisplayName
                          FolderPath = $folderPath
                          ContentFile = $contentFile
                          IpynbFile = $ipynbFile
                          PlatformFile = $platformFile.FullName
                          LakehouseName = $lakehouseName
                          LakehouseId = $lakehouseId
                          EnvironmentId = $resolvedEnvironmentId
                          EnvironmentIdPython = $environmentIdPython
                          WorkspaceId = $WorkspaceId
                      }
                     
                  } catch {
                      Write-Host "##vso[task.LogIssue type=error;]Error processing notebook '$($platformFile.Name)': $($_.Exception.Message)"
                      Write-Host "##[debug]Stack Trace: $($_.ScriptStackTrace)"
                      continue
                  }
              }
             
              Write-Host "##[section]Phase 1: Updating Notebook Dependencies"
             
              # Phase 1: Update notebook dependencies
              foreach ($notebook in $notebookConfigs) {
                  try {
                      Write-Host "##[debug]Updating dependencies for: $($notebook.DisplayName)"
                     
                      $updateScript = "$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts/Update-NotebookDependencies.ps1"
                      $updateParams = @(
                          "-KeyVaultName", "'$env:TF_VAR_keyvault_name'"
                          "-WorkspaceId", "'$($notebook.WorkspaceId)'"
                          "-EnvironmentId", "'$($notebook.EnvironmentId)'"
                          "-EnvironmentIdPython", "'$($notebook.EnvironmentIdPython)'"
                          "-NotebookPath", "'$($notebook.ContentFile)'"
                      )
                     
                      if ($notebook.LakehouseName -ne "null" -and $null -ne $notebook.LakehouseId) {
                          $updateParams += "-LakehouseName", "'$($notebook.LakehouseName)'"
                          $updateParams += "-LakehouseId", "'$($notebook.LakehouseId)'"
                      }
                     
                      $updateCommand = "& '$updateScript' $($updateParams -join ' ')"
                      Write-Host "##[debug]Executing: $updateCommand"
                     
                      Invoke-Expression $updateCommand
                     
                      Write-Host "##[debug]Dependencies updated successfully for: $($notebook.DisplayName)"
                     
                  } catch {
                      Write-Host "##vso[task.LogIssue type=warning;]Failed to update dependencies for '$($notebook.DisplayName)': $($_.Exception.Message)"
                      continue
                  }
              }
             
              Write-Host "##[section]Phase 2: Creating/Updating Notebooks"
             
              # Phase 2: Create/Update notebooks
              $createdNotebooks = @()
             
              foreach ($notebook in $notebookConfigs) {
                  try {
                      Write-Host "##[debug]Creating/Updating notebook: $($notebook.DisplayName)"
                     
                      $notebookScript = "$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts/Invoke-NotebookManagement.ps1"
                      $folderHierarchy = if ([string]::IsNullOrEmpty($env:FOLDER_HIERARCHY)) { $null } else { $env:FOLDER_HIERARCHY }
                     
                      $notebookParams = @(
                          "-Action", "'CreateOrUpdate'"
                          "-WorkspaceId", "'$($notebook.WorkspaceId)'"
                          "-DisplayName", "'$($notebook.DisplayName)'"
                          "-IpynbFile", "'$($notebook.IpynbFile)'"
                          "-PlatformFile", "'$($notebook.PlatformFile)'"
                      )
                     
                      if (![string]::IsNullOrEmpty($folderHierarchy)) {
                          $notebookParams += "-FolderHierarchy", "'$folderHierarchy'"
                      }
                     
                      if (![string]::IsNullOrEmpty($notebook.FolderPath)) {
                          $notebookParams += "-FolderPath", "'$($notebook.FolderPath)'"
                      }
                     
                      if ($notebook.EnvironmentId -ne "00000000-0000-0000-0000-000000000000") {
                          $notebookParams += "-EnvironmentId", "'$($notebook.EnvironmentId)'"
                      }
                     
                      if ($notebook.LakehouseName -ne "null") {
                          $notebookParams += "-LakehouseName", "'$($notebook.LakehouseName)'"
                          if ($null -ne $notebook.LakehouseId) {
                              $notebookParams += "-LakehouseId", "'$($notebook.LakehouseId)'"
                          }
                      }
                     
                      $notebookCommand = "& '$notebookScript' $($notebookParams -join ' ')"
                      Write-Host "##[debug]Executing: $notebookCommand"
                     
                      $notebookResult = Invoke-Expression $notebookCommand
                     
                      if ($notebookResult) {
                          Write-Host "##[section]Notebook '$($notebook.DisplayName)' created/updated successfully"
                         
                          $createdNotebooks += @{
                              DisplayName = $notebook.DisplayName
                              WorkspaceId = $notebook.WorkspaceId
                              FolderPath = $notebook.FolderPath
                          }
                      } else {
                          Write-Host "##vso[task.LogIssue type=warning;]Failed to create/update notebook: $($notebook.DisplayName)"
                      }
                     
                  } catch {
                      Write-Host "##vso[task.LogIssue type=error;]Error creating/updating notebook '$($notebook.DisplayName)': $($_.Exception.Message)"
                      Write-Host "##[debug]Stack Trace: $($_.ScriptStackTrace)"
                      continue
                  }
              }
             
              Write-Host "##[section]Notebook creation/update process completed. Processed $($createdNotebooks.Count) notebooks."
             
              # Create a summary of created notebooks for pipeline variables
              if ($createdNotebooks.Count -gt 0) {
                  $notebookSummary = $createdNotebooks | ConvertTo-Json -Compress
                  Write-Host "##[debug]Created Notebooks Summary: $notebookSummary"
                  Write-Host "##vso[task.setvariable variable=CREATED_NOTEBOOKS]$notebookSummary"
              } else {
                  Write-Host "##vso[task.setvariable variable=CREATED_NOTEBOOKS][]"
              }
             
          } catch {
              Write-Host "##vso[task.LogIssue type=error;]Error processing notebooks: $($_.Exception.Message)"
              Write-Host "##vso[task.LogIssue type=error;]Stack Trace: $($_.ScriptStackTrace)"
              Write-Host "##vso[task.complete result=Failed;]"
              exit 1
          }
        pwsh: false
        workingDirectory: '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts'
      env:
        ARM_CLIENT_ID: $(ARM_CLIENT_ID)
        ARM_CLIENT_SECRET: $(ARM_CLIENT_SECRET)
        ARM_TENANT_ID: $(ARM_TENANT_ID)
      displayName: 'Create and Update Fabric Notebooks'

    - task: PowerShell@2
      inputs:
        targetType: 'inline'
        script: |
          try {
              Write-Host "##[section]Creating Fabric KQL Dashboards"
             
              # Parse workspace configuration
              $WorkspaceName = $env:TF_VAR_workspace_names
              $WorkspaceName = $WorkspaceName.Replace('[', '["').Replace(']', '"]').Replace(',', '","') -replace '"\s+', '"'
              $WorkspaceName = $WorkspaceName.Trim('[', ']').Trim('"')
             
              # Get workspace ID from previous step
              $WorkspaceId = $env:WORKSPACE_ID
             
              # Find KQL Dashboard platform files
              $srcFabricPath = "$(System.DefaultWorkingDirectory)/src/fabric"
              $platformFiles = Get-ChildItem -Path $srcFabricPath -Recurse -Filter ".platform" | Where-Object {
                  $_.Directory.Name -like "*.KQLDashboard"
              }
             
              if ($platformFiles.Count -eq 0) {
                  Write-Host "##[warning]No KQL Dashboard platform files found, skipping dashboard creation"
                  return
              }
             
              Write-Host "##[debug]Found $($platformFiles.Count) KQL Dashboard platform files"
             
              # Create dashboards for each platform file found
              $createdDashboards = @()
             
              foreach ($platformFile in $platformFiles) {
                  try {
                      # Read platform file
                      $platformContent = Get-Content $platformFile.FullName -Raw | ConvertFrom-Json
                      $dashboardDisplayName = $platformContent.metadata.displayName
                      $dashboardDescription = if ($platformContent.metadata.PSObject.Properties['description']) {
                          $platformContent.metadata.description
                      } else {
                          ""
                      }
                     
                      # Get folder path relative to src/fabric
                      $fullPath = $platformFile.Directory.FullName
                      $folderPath = $fullPath -replace '.*src[/\\]fabric[/\\]', ''
                     
                      # Look for RealTimeDashboard.json content file
                      $contentFile = Join-Path $platformFile.Directory.FullName "RealTimeDashboard.json"
                      $dashboardContent = $null
                     
                      if (Test-Path $contentFile) {
                          $dashboardContent = Get-Content $contentFile -Raw
                          Write-Host "##[debug]Found dashboard content file: $contentFile"
                      } else {
                          Write-Host "##[warning]Dashboard content file not found: $contentFile"
                      }
                     
                      Write-Host "##[debug]Processing KQL Dashboard:"
                      Write-Host "##[debug]  Display Name: $dashboardDisplayName"
                      Write-Host "##[debug]  Description: $dashboardDescription"
                      Write-Host "##[debug]  Folder Path: $folderPath"
                      Write-Host "##[debug]  Content File: $contentFile"
                     
                      # Create dashboard using PowerShell script
                      $scriptPath = "$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts/Invoke-KQLDashboardManagement.ps1"
                      $folderHierarchy = if ([string]::IsNullOrEmpty($env:FOLDER_HIERARCHY)) { $null } else { $env:FOLDER_HIERARCHY }
                     
                      # Build parameters dynamically
                      $dashboardParams = @(
                          "-Action", "'CreateOrUpdate'"
                          "-WorkspaceId", "'$WorkspaceId'"
                          "-DisplayName", "'$dashboardDisplayName'"
                          "-PlatformFile", "'$($platformFile.FullName)'"
                      )
                     
                      # Add optional parameters only if they have values
                      if (![string]::IsNullOrEmpty($dashboardDescription)) {
                          $dashboardParams += "-Description", "'$dashboardDescription'"
                      }
                     
                      if ($null -ne $dashboardContent -and (Test-Path $contentFile)) {
                          $dashboardParams += "-ContentFile", "'$contentFile'"
                      }
                     
                      if (![string]::IsNullOrEmpty($folderHierarchy)) {
                          $dashboardParams += "-FolderHierarchy", "'$folderHierarchy'"
                      }
                     
                      if (![string]::IsNullOrEmpty($folderPath)) {
                          $dashboardParams += "-FolderPath", "'$folderPath'"
                      }
                     
                      # Execute the dashboard creation script
                      $dashboardCommand = "& '$scriptPath' $($dashboardParams -join ' ')"
                      Write-Host "##[debug]Executing: $dashboardCommand"
                     
                      $dashboardResult = Invoke-Expression $dashboardCommand
                     
                      if ($dashboardResult) {
                          Write-Host "##[section]KQL Dashboard '$dashboardDisplayName' created/updated successfully"
                         
                          $createdDashboards += @{
                              DisplayName = $dashboardDisplayName
                              Description = $dashboardDescription
                              WorkspaceId = $WorkspaceId
                              FolderPath = $folderPath
                              ContentFile = $contentFile
                          }
                      } else {
                          Write-Host "##vso[task.LogIssue type=warning;]Failed to create/update KQL dashboard: $dashboardDisplayName"
                      }
                     
                  } catch {
                      Write-Host "##vso[task.LogIssue type=error;]Error processing KQL dashboard '$($platformFile.Name)': $($_.Exception.Message)"
                      Write-Host "##[debug]Stack Trace: $($_.ScriptStackTrace)"
                      continue
                  }
              }
             
              Write-Host "##[section]KQL Dashboard creation/update process completed. Processed $($createdDashboards.Count) dashboards."
             
              # Create a summary of created dashboards for pipeline variables
              if ($createdDashboards.Count -gt 0) {
                  $dashboardSummary = $createdDashboards | ConvertTo-Json -Compress
                  Write-Host "##[debug]Created KQL Dashboards Summary: $dashboardSummary"
                  Write-Host "##vso[task.setvariable variable=CREATED_KQL_DASHBOARDS]$dashboardSummary"
                 
                  # Create a comma-separated list of dashboard names
                  $dashboardNames = ($createdDashboards | ForEach-Object { $_.DisplayName }) -join ", "
                  Write-Host "##vso[task.setvariable variable=KQL_DASHBOARD_NAMES]$dashboardNames"
              } else {
                  Write-Host "##vso[task.setvariable variable=CREATED_KQL_DASHBOARDS][]"
                  Write-Host "##vso[task.setvariable variable=KQL_DASHBOARD_NAMES]"
              }
             
          } catch {
              Write-Host "##vso[task.LogIssue type=error;]Error creating KQL dashboards: $($_.Exception.Message)"
              Write-Host "##vso[task.LogIssue type=error;]Stack Trace: $($_.ScriptStackTrace)"
              Write-Host "##vso[task.complete result=Failed;]"
              exit 1
          }
        pwsh: false
        workingDirectory: '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts'
      env:
        ARM_CLIENT_ID: $(ARM_CLIENT_ID)
        ARM_CLIENT_SECRET: $(ARM_CLIENT_SECRET)
        ARM_TENANT_ID: $(ARM_TENANT_ID)
      displayName: 'Create Fabric KQL Dashboards'

    - powershell: |
        # Set ErrorActionPreference to Stop so any errors will halt execution
        $ErrorActionPreference = "Stop"
       
        try {
            $admin_group_principal_ids = $env:TF_VAR_admin_group_principal_ids
            $admin_sp_principal_ids = $env:TF_VAR_admin_sp_principal_ids
            $contributor_group_principal_ids = $env:TF_VAR_contributor_group_principal_ids
            $viewer_group_principal_ids = $env:TF_VAR_viewer_group_principal_ids
            $admin_user_principal_ids = $env:TF_VAR_admin_user_principal_ids
            $workspace_names = $env:TF_VAR_workspace_names
            $parent_domain_name = "$(PARENT_DOMAIN_NAME)"
            $child_domain_name = "$(CHILD_DOMAIN_NAME)"
         
            Write-Host "workspace_names: $workspace_names"
            Write-Host "##vso[task.setvariable variable=PARENT_DOMAIN_NAME]$parent_domain_name"
            Write-Host "##vso[task.setvariable variable=CHILD_DOMAIN_NAME]$child_domain_name"
           
            # if empty array, leave as is no substitution needed
            if ($admin_group_principal_ids -ne '[]') {
              $admin_group_principal_ids = $admin_group_principal_ids.Replace('[', '["').Replace(']', '"]').Replace(',', '","').Replace(' ', '')
            }

            if ($viewer_group_principal_ids -ne '[]') {
              $viewer_group_principal_ids = $viewer_group_principal_ids.Replace('[', '["').Replace(']', '"]').Replace(',', '","').Replace(' ', '')
            }
           
            if ($contributor_group_principal_ids -ne '[]') {
              $contributor_group_principal_ids = $contributor_group_principal_ids.Replace('[', '["').Replace(']', '"]').Replace(',', '","').Replace(' ', '')
            }
           
            write-host "##vso[task.setvariable variable=ADMIN_GROUP_PRINCIPAL_IDS]$admin_group_principal_ids"
           
            $admin_sp_principal_ids = $admin_sp_principal_ids.Replace('[', '["').Replace(']', '"]').Replace(',', '","').Replace(' ', '')
           
            $admin_user_principal_ids = $admin_user_principal_ids.Replace('[', '["').Replace(']', '"]').Replace(',', '","').Replace(' ', '')
           
            $workspace_names = $workspace_names.Replace('[', '["').Replace(']', '"]').Replace(',', '","') -replace '"\s+', '"'
           
            Write-Host "Admin Group Principal IDs: $admin_group_principal_ids"
            Write-Host "Admin SP Principal IDs: $admin_sp_principal_ids"
            Write-Host "Workspace Names: $workspace_names"
         
            $default_spark_environment_name = if ([string]::IsNullOrEmpty($env:TF_VAR_default_spark_environment_name)) {
              "null"
            } else {
              "$env:TF_VAR_default_spark_environment_name"
            }
           
            $default_spark_runtime = $env:TF_VAR_default_spark_runtime
            $shortcuts = $env:FABRIC_SHORTCUTS_DETAILED -replace '"', '\"'
            $peps = $env:FABRIC_PEP_DETAILED -replace '"', '\"'
            $folder_hierarchy = $env:FOLDER_HIERARCHY -replace '"', '\"'
            $environment = $env:TF_VAR_environment
            $keyvault_name = $env:TF_VAR_keyvault_name
            $capacity_id = $env:TF_VAR_capacity_id
            $forceDeletionPPE = [System.Convert]::ToBoolean("${{ parameters.forceDeletionPPE }}")
           
            Write-Host "##[debug]Folder Hierarchy for terraform: $folder_hierarchy"

            $formattedSparkCompute = @{}
            foreach ($item in (Get-Item env:*)) { 
                if ($item.Name.ToLower().StartsWith('sparkcompute_')) {
                    # Extract original name without prefix
                    $displayName = $item.Name.ToLower().Replace('sparkcompute_', '')

                    # Add formatted spark compute object
                    $formattedSparkCompute[$displayName] = $item.Value

                }
            }
            Write-Host "##[debug]Formatted Spark Compute: $($formattedSparkCompute | ConvertTo-Json -Compress)"

            $sparkComputeJson = $formattedSparkCompute | ConvertTo-Json -Compress 
            $sparkComputeJson = $sparkComputeJson -replace '"', '\"' # Escape quotes for JSON string

            # Create tfvars content - Use PowerShell variables instead of env variables in here-string
            @"
              admin_group_principal_ids = $admin_group_principal_ids
              viewer_group_principal_ids = $viewer_group_principal_ids              
              admin_sp_principal_ids = $admin_sp_principal_ids
              contributor_group_principal_ids = $contributor_group_principal_ids
              admin_user_principal_ids = $admin_user_principal_ids
              environment = "$environment"
              keyvault_name = "$keyvault_name"
              workspace_names = $workspace_names
              capacity_id = "$capacity_id"
              default_spark_environment_name = "$default_spark_environment_name"
              parent_domain_name = "$parent_domain_name"
              child_domain_name = "$child_domain_name"        
              shortcuts = "$shortcuts"
              peps = "$peps"
              folder_hierarchy = "$folder_hierarchy"
              default_spark_runtime = "$default_spark_runtime"
              force_deletion_ppe = $($forceDeletionPPE.ToString().ToLower())
              spark_compute = "$sparkComputeJson"
              workspace_id = "$env:WORKSPACE_ID"
        "@ | Out-File -FilePath "terraform.tfvars" -Encoding UTF8
         
            # Show tfvars content for debugging
            Write-Host "`nCreated terraform.tfvars content:"
            Get-Content "terraform.tfvars"

            # Function to execute Terraform commands with error handling
            function Invoke-TerraformCommand {
                param(
                    [string]$Command,
                    [string]$Description
                )
               
                Write-Host "`n##[section]$Description"
                Write-Host "Executing: $Command"
               
                # Capture output and error streams
                $process = Start-Process -FilePath "terraform" -ArgumentList $Command.Split(' ', [StringSplitOptions]::RemoveEmptyEntries) -PassThru -NoNewWindow -RedirectStandardOutput stdout.txt -RedirectStandardError stderr.txt -Wait
               
                # Read outputs
                $stdout = Get-Content stdout.txt -Raw -ErrorAction SilentlyContinue
                $stderr = Get-Content stderr.txt -Raw -ErrorAction SilentlyContinue
               
                # Clean up temp files
                Remove-Item stdout.txt -ErrorAction SilentlyContinue
                Remove-Item stderr.txt -ErrorAction SilentlyContinue
               
                # Output the results
                if ($stdout) {
                    Write-Host $stdout
                }
               
                # Check exit code and handle errors
                if ($process.ExitCode -ne 0) {
                    Write-Host "##vso[task.LogIssue type=error;]Terraform command failed with exit code: $($process.ExitCode)"
                    if ($stderr) {
                        Write-Host "##vso[task.LogIssue type=error;]Error Output: $stderr"
                    }
                    Write-Host "##vso[task.complete result=Failed;]"
                    throw "Terraform command '$Command' failed with exit code $($process.ExitCode)"
                }
               
                if ($stderr -and $stderr.Contains("Error")) {
                    Write-Host "##vso[task.LogIssue type=warning;]Warning Output: $stderr"
                }
               
                Write-Host "##[section]$Description completed successfully"
            }
          
            # Execute Terraform commands with error handling
            Invoke-TerraformCommand -Command "plan -out=tfplan -var-file=terraform.tfvars" -Description "Terraform Plan"
           
            Invoke-TerraformCommand -Command "apply --target=module.notebooks.null_resource.create_notebooks -auto-approve" -Description "Apply Notebooks Creation"
           
            Invoke-TerraformCommand -Command "refresh" -Description "Terraform Refresh"
           
            Invoke-TerraformCommand -Command "apply --target=module.ellie_notebooks[0].local_file.notebook_ipynb -auto-approve" -Description "Apply Ellie Notebooks"
           
            Invoke-TerraformCommand -Command "refresh" -Description "Terraform Refresh"
           
            Invoke-TerraformCommand -Command "apply -auto-approve" -Description "Final Terraform Apply"
           
            # Generate output with error handling
            Write-Host "`n##[section]Generating Terraform Output"
            $outputProcess = Start-Process -FilePath "terraform" -ArgumentList "output", "-json" -PassThru -NoNewWindow -RedirectStandardOutput tf_output.json -RedirectStandardError terraform_output_error.txt -Wait
           
            if ($outputProcess.ExitCode -ne 0) {
                $outputError = Get-Content terraform_output_error.txt -Raw -ErrorAction SilentlyContinue
                Write-Host "##vso[task.LogIssue type=error;]Terraform output command failed with exit code: $($outputProcess.ExitCode)"
                if ($outputError) {
                    Write-Host "##vso[task.LogIssue type=error;]Output Error: $outputError"
                }
                throw "Terraform output generation failed"
            }
           
            Write-Host "Terraform output generated successfully"
           
        } catch {
            Write-Host "##vso[task.LogIssue type=error;]PowerShell script error: $($_.Exception.Message)"
            Write-Host "##vso[task.LogIssue type=error;]Stack Trace: $($_.ScriptStackTrace)"
            Write-Host "##vso[task.complete result=Failed;]"
            exit 1
        }

      workingDirectory: $(workingDirectory)
      displayName: 'Terraform Apply Fabric Artifacts'    
      env:
        SERVICE_ACCOUNT_NAME: $(SERVICE_ACCOUNT_NAME)
        SERVICE_ACCOUNT_SECRET: $(SERVICE_ACCOUNT_SECRET)
        ARM_TENANT_ID: $(ARM_TENANT_ID)
        
    - powershell: |
        # Read and parse JSON
        $outputJson = Get-Content -Path tf_output.json
        Write-Host "Output json: $outputJson"
        $tfOutput = Get-Content -Path tf_output.json | ConvertFrom-Json

        # Get first workspace key and ID
        $workspaceKey = $tfOutput.workspace_ids.value.PSObject.Properties.Name
        $workspaceId = $tfOutput.workspace_ids.value.$workspaceKey

        $workspaceIds = $tfOutput.workspace_ids.value
        Write-Host "Workspace IDs: $($workspaceIds | ConvertTo-Json -Compress)"

        Write-Host "Workspace Key: $workspaceKey"
        Write-Host "Workspace ID: $workspaceId"

        # Get enviroment IDs
        $environmentKey = $tfOutput.environment_ids.value.PSObject.Properties.Name
        $environmentId = $tfOutput.environment_ids.value.$environmentKey
        write-host "Environment ID: $environmentId"        

        # Get fabric connections
        $fabricConnections = $tfOutput.fabric_connections.value
        Write-Host "Fabric Connections:"
        foreach ($connection in $fabricConnections) {
            Write-Host "Display Name: $($connection.displayName)"
            Write-Host "ID: $($connection.id)"
        }

        $workspace_names = $env:TF_VAR_workspace_names
        $workspace_names = $workspace_names.Replace('[', '["').Replace(']', '"]').Replace(',', '","') -replace '"\s+', '"'
        $workspace_name = $workspace_names.Replace('["', '').Replace('"]', '').Replace('","', ',')
        $ellie_notebookIds = $tfOutput.ellie_notebook_ids.value

        # Store as variables
        Write-Host "##vso[task.setvariable variable=WORKSPACE_ID]$workspaceId"
        Write-Host "##vso[task.setvariable variable=WORKSPACE_IDS]$($workspaceIds | ConvertTo-Json -Compress)"
        Write-Host "##vso[task.setvariable variable=ENVIRONMENT_ID]$environmentId"
        Write-Host "##vso[task.setvariable variable=WORKSPACE_NAME]$workspace_name"
        Write-Host "##vso[task.setvariable variable=FABRIC_CONNECTIONS]$($fabricConnections | ConvertTo-Json -Compress)"     
        Write-Host "##vso[task.setvariable variable=ELLIE_NOTEBOOK_IDS]$($ellie_notebookIds | ConvertTo-Json -Compress)"     

      workingDirectory: $(workingDirectory)
      displayName: 'Exposing Terraform Outputs'    
      

    # - task: PowerShell@2
    #   name: handlePrivateEndpointApprovals
    #   displayName: 'Handle Private Endpoint Approvals'
    #   inputs:
    #     targetType: 'filePath'
    #     filePath: '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts/Handle-PrivateEndpointApprovals.ps1'
    #     arguments: >-
    #       -PepDetailedJson '$(FABRIC_PEP_DETAILED)'
    #       -WorkspaceId '$(WORKSPACE_ID)'
    #       -WorkspaceName '$(WORKSPACE_NAME)'
    #       -ForceDeletionPPE:$${{ parameters.forceDeletionPPE }}
    #       -ScriptBasePath '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts'
    #     pwsh: false
    #     workingDirectory: '$(System.DefaultWorkingDirectory)'
    #   env:
    #     FABRIC_TOKEN: $(FABRIC_TOKEN)
    #     ARM_TENANT_ID: $(ARM_TENANT_ID)
    #     ARM_CLIENT_ID: $(ARM_CLIENT_ID)
    #     ARM_CLIENT_SECRET: $(ARM_CLIENT_SECRET)
    #   condition: and(succeeded(), ne(variables['FABRIC_PEP_DETAILED'], ''))
    #   continueOnError: false

    - task: PowerShell@2
      displayName: 'Retrieve and Process Fabric Notebooks'
      inputs:
        targetType: 'inline'
        script:  |
        
          Write-Host "Listing notebooks in workspace"
          
          $token = $env:FABRIC_TOKEN
          $workspaceIds = ConvertFrom-Json -InputObject $env:WORKSPACE_IDS

          $workspaceId = $workspaceIds.PSObject.Properties.Value
          Write-Host ("Using workspace ID: " + $workspaceId)

          $response = Invoke-RestMethod -Uri "https://api.fabric.microsoft.com/v1/workspaces/$workspaceId/notebooks" -Method Get -Headers @{
              "Authorization" = "Bearer $token"
          }
          $notebookIds = ($response.value | ConvertTo-Json -Compress)
          Write-Host ("Notebook IDs: " + $notebookIds)
          
          Write-Host "##vso[task.setvariable variable=NOTEBOOK_IDS]$notebookIds"

          # Filter notebooks with '_cicd_' in the display name and set corresponding variable
          $filteredNotebooks = $response.value | Where-Object { $_.displayName -like "*_cicd_*" }

          # Only convert to array if it's not already an array
          if ($filteredNotebooks -and $filteredNotebooks -isnot [Array]) {
              $filteredNotebooks = @($filteredNotebooks)
          }

          if ($filteredNotebooks -and $filteredNotebooks.Count -gt 0) {
            $notebookIds = ($filteredNotebooks.id | ConvertTo-Json -Compress)
            Write-Host ("Filtered Notebook IDs: " + $notebookIds)
            Write-Host "##vso[task.setvariable variable=CICD_NOTEBOOK_IDS]$notebookIds" 
            Write-Host "##vso[task.setvariable variable=HAS_CICD_NOTEBOOKS]true"     
          } else {           
            Write-Host "No notebooks found with '_cicd_' in the display name."
            Write-Host "##vso[task.setvariable variable=CICD_NOTEBOOK_IDS][]"
            Write-Host "##vso[task.setvariable variable=HAS_CICD_NOTEBOOKS]false"
          }

    - task: PowerShell@2
      displayName: 'Verify Environment Variables'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Parent domain name: $env:PARENT_DOMAIN_NAME"
          Write-Host "Child domain name: $env:CHILD_DOMAIN_NAME"
          Write-Host "Workspace IDs:  $env:WORKSPACE_IDS"
          Write-Host "Admin Group Principal IDs: $env:ADMIN_GROUP_PRINCIPAL_IDS"

    - task: PowerShell@2
      displayName:  'Fabric Domain Configuration'     
      inputs:
        targetType: 'filePath'
        filePath: $(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts/Setup-FabricDomains.ps1
        workingDirectory: '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts'        
      env:
        FABRIC_TOKEN: $env:FABRIC_TOKEN
        WORKSPACE_IDS: $env:WORKSPACE_IDS   
        PARENT_DOMAIN_NAME: $env:PARENT_DOMAIN_NAME
        CHILD_DOMAIN_NAME: $env:CHILD_DOMAIN_NAME
        ADMIN_GROUP_PRINCIPAL_IDS: $env:ADMIN_GROUP_PRINCIPAL_IDS

    - task: PowerShell@2
      name: prepVars
      displayName: 'Expose original Fabric Connections'
      inputs:
        targetType: 'inline'
        script: |
          try {
              # Create empty array for formatted connections
              $formattedConnections = @()
              
              Write-Host "##[debug]Variables:"
              foreach ($item in (Get-Item env:*)) {
                  if ($item.Name.ToLower().StartsWith('connection_')) {
                      # Extract original name without prefix
                      $displayName = $item.Name.Replace('CONNECTION_', '')
                      
                      # Add formatted connection object to array
                      $formattedConnections += @{
                          displayName = $displayName.ToLower()
                          searchId = $item.Value
                      }
    
                      Write-Host "##[debug]Added connection: $displayName"
                  }
              }
    
              $connectionsJson = $formattedConnections | ConvertTo-Json -Compress
              Write-Host "##[debug]Fabric Connections: $($formattedConnections | ConvertTo-Json)"
              Write-Host "##vso[task.setvariable variable=FABRIC_ORIGINAL_CONNECTIONS]$connectionsJson"
          }
          catch {
              Write-Error "Error: $_"
              Write-Error $_.ScriptStackTrace
              exit 1
          }

    - task: PowerShell@2
      displayName: 'Fabric Data Pipelines Configuration'
      inputs:
        targetType: 'inline'
        script: |
          $folder_hierarchy = $env:FOLDER_HIERARCHY 
          $scriptPath = '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts/Setup-FabricDataPipelines.ps1'
          & $scriptPath -FolderHierarchy $folder_hierarchy
        workingDirectory: '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts'
      env:
        FABRIC_TOKEN: $env:FABRIC_TOKEN
        WORKSPACE_IDS: $env:WORKSPACE_IDS
        FABRIC_CONNECTIONS: $env:FABRIC_CONNECTIONS
        NOTEBOOK_IDS: $env:NOTEBOOK_IDS
        FABRIC_ORIGINAL_CONNECTIONS: $env:FABRIC_ORIGINAL_CONNECTIONS
        FABRIC_MANAGED_CONNECTIONS_DETAILED: $env:FABRIC_MANAGED_CONNECTIONS_DETAILED
            
    - task: PowerShell@2
      displayName: 'Run CICD Notebooks'
      inputs:
        targetType: 'inline'
        script: |

          # Check if we have CICD notebooks to run
          $hasCicdNotebooks = $env:HAS_CICD_NOTEBOOKS
          Write-Host "Has CICD notebooks flag: $hasCicdNotebooks"
        
          if ($hasCicdNotebooks -ne 'true') {
              Write-Host "##[warning]No CICD notebooks found to execute. Skipping notebook execution."
              exit 0
          }
          # Parse the JSON string of notebook IDs
          $notebookIds = $null
          try {
            $notebookIds = ConvertFrom-Json -InputObject $env:CICD_NOTEBOOK_IDS -ErrorAction Stop
            Write-Host "Found notebook IDs: $($notebookIds | ConvertTo-Json -Compress)"
          }
          catch {
            Write-Warning "Error parsing CICD_NOTEBOOK_IDS: $_"
            Write-Host "Raw value: $env:CICD_NOTEBOOK_IDS"
            exit 1
          }
          
          # Get workspace ID
          $workspaceIds = ConvertFrom-Json -InputObject $env:WORKSPACE_IDS
          $workspaceId = $workspaceIds.PSObject.Properties.Value
          Write-Host "Using workspace ID: $workspaceId"
          
          # Set up headers for API calls
          $Headers = @{
            "Authorization" = "Bearer $env:FABRIC_TOKEN"
          }
          
          # Track results
          $runResults = @()
          
          # Iterate through each notebook ID and run it
          foreach ($notebookId in $notebookIds) {
            try {
              Write-Host "Starting notebook: $notebookId"
              
              # Send request to start the notebook using WebRequest to get headers
              $startNotebookUrl = "https://api.fabric.microsoft.com/v1/workspaces/$workspaceId/items/$notebookId/jobs/instances?jobType=RunNotebook"
              $startResponse = Invoke-WebRequest -Uri $startNotebookUrl -Headers $Headers -Method POST -UseBasicParsing
              
              # Get the job URL from the Location header
              $notebookJobUrl = $startResponse.Headers["Location"]
              
              Write-Host "NotebookJobUrl: $notebookJobUrl"


              $waitJobsToFinish = [System.Convert]::ToBoolean("${{ parameters.waitJobsToFinish }}")
              if (-not $waitJobsToFinish) {
                  Write-Host "##[section]Not waiting for notebook execution to complete as per configuration."
                  continue
              }

              if ($notebookJobUrl) {
                  $maxWaitTime = 600  # 10 minutes
                  $waitTime = 0
                
                  do {
                      Start-Sleep -Seconds 10
                      $waitTime += 10
                    
                      try {
                          $statusResponse = Invoke-RestMethod -Uri $notebookJobUrl -Headers $Headers -Method GET
                          Write-Host "##[debug]Job Status: $($statusResponse.status)"
                        
                          if ($statusResponse.status -eq "Completed") {
                              Write-Host "##[section]Notebook execution completed successfully"
                              break
                          } elseif ($statusResponse.status -eq "Failed") {
                              Write-Host "##[error]Notebook execution failed: $($statusResponse.error)"
                              break
                          }
                      } catch {
                          Write-Host "##[warning]Could not check job status: $($_.Exception.Message)"
                      }
                  } while ($waitTime -lt $maxWaitTime)
              }

            }
            catch {
              Write-Warning "Failed to run notebook $notebookId - Error: $_"
              $runResults += [PSCustomObject]@{
                NotebookId = $notebookId
                JobUrl = "Error"
                InitialStatus = "Failed"
                Error = $_.Exception.Message
              }
            }
          }

        pwsh: false
        workingDirectory: '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts'
      env:
        FABRIC_TOKEN: $env:FABRIC_TOKEN
        CICD_NOTEBOOK_IDS: $env:CICD_NOTEBOOK_IDS
        WORKSPACE_IDS: $env:WORKSPACE_IDS

    - task: PowerShell@2         
      displayName: 'Configure and Deploy Semantic Models'
      inputs:    
        targetType: 'inline'
        script: |
          
          $pwshPath = 'C:\Program Files\PowerShell\7\pwsh.exe'
          $workspaceIds = ConvertFrom-Json -InputObject $env:WORKSPACE_IDS

          $workspaceId = $workspaceIds.PSObject.Properties.Value
          
          Write-Host "Deploying Fabric Semantic Models for $workspaceId"

          $folder_hierarchy = $env:FOLDER_HIERARCHY

          Write-Host "Folder Hierarchy: $folder_hierarchy"

          $scriptPath = '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts/Deploy-FabricSemanticModels.ps1'
          & $scriptPath -FolderHierarchy $folder_hierarchy -SemanticModelsDetailJson $env:FABRIC_SEMANTIC_MODELS_DETAILED -SemanticModelsParametersDetailJson $env:FABRIC_SEMANTIC_MODELS_PARAMETER_DETAILED

        pwsh: false
        workingDirectory: '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts'    
      env:
        FABRIC_TOKEN: $env:FABRIC_TOKEN
        WORKSPACE_IDS: $env:WORKSPACE_IDS

    - task: PowerShell@2
      displayName: 'Configure and Deploy Reports'
      inputs:
        targetType: 'inline'
        script: |
          
          $pwshPath = 'C:\Program Files\PowerShell\7\pwsh.exe'
          $workspaceIds = ConvertFrom-Json -InputObject $env:WORKSPACE_IDS

          $workspaceId = $workspaceIds.PSObject.Properties.Value
          
          Write-Host "Deploying Fabric Reports for $workspaceId"

          $folder_hierarchy = $env:FOLDER_HIERARCHY

          Write-Host "Folder Hierarchy: $folder_hierarchy"
          
          $scriptPath = '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts/Deploy-FabricReports.ps1'
          & $scriptPath -FolderHierarchy $folder_hierarchy
          
        pwsh: false
        workingDirectory: '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts'         
      env:
        FABRIC_TOKEN: $env:FABRIC_TOKEN
        WORKSPACE_IDS: $env:WORKSPACE_IDS     

    - task: PowerShell@2
      displayName: 'Upload & Publish Environment Spark Libraries'
      inputs:
        targetType: 'inline'
        script: |
          
          $env:UPGRADE_SPARK_LIBRARIES = "${{ parameters.upgradeSparkLibraries }}"
          $pwshPath = 'C:\Program Files\PowerShell\7\pwsh.exe'
          $workspaceIds = ConvertFrom-Json -InputObject $env:WORKSPACE_IDS

          $workspaceId = $workspaceIds.PSObject.Properties.Value
          
          Write-Host "Deploying Fabric Environment Spark Libraries $workspaceId"

          & $pwshPath -File $scriptPath '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts/Deploy-FabricEnvironmentSparkLibraries.ps1'

        pwsh: false
        workingDirectory: '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts'
      env:
        FABRIC_TOKEN: $env:FABRIC_TOKEN
        WORKSPACE_IDS: $env:WORKSPACE_IDS
        UPGRADE_SPARK_LIBRARIES: $env:UPGRADE_SPARK_LIBRARIES 

    - task: PowerShell@2
      condition: eq(${{ parameters.isGitConnect }}, true)
      displayName: 'Git Connect and Sync'
      name: gitConnect
      inputs:
        targetType: 'filePath'
        filePath: '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts/Fabric-GitOperations.ps1'
        workingDirectory: '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts'
        arguments: >
          -Organization "$(TARGET_ORGANIZATION)"
          -Project "$(TARGET_PROJECT)"
          -Repository "$(TARGET_REPOSITORY)"
      env:
        FABRIC_TOKEN: $env:FABRIC_TOKEN  
        WORKSPACE_IDS: $env:WORKSPACE_IDS             

    - task: PowerShell@2
      displayName: 'Upload Monitoring Workspace Files'
      inputs:
        targetType: 'inline'
        script: |
          
          $pwshPath = 'C:\Program Files\PowerShell\7\pwsh.exe'
          $workspaceIds = ConvertFrom-Json -InputObject $env:WORKSPACE_IDS

          $workspaceId = $workspaceIds.PSObject.Properties.Value
          
          Write-Host "Uploading files to $workspaceId"

          & $pwshPath -File $scriptPath '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts/Fabric-LakehouseUpload.ps1'

        pwsh: false
        workingDirectory: '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts'
      env:
        FABRIC_TOKEN: $env:FABRIC_TOKEN
        WORKSPACE_IDS: $env:WORKSPACE_IDS
        LAKEHOUSE_NAME: 'den_lhw_pdv_001_semanticmodel_monitoring'
        SOURCE_PATH: 'src/documents/BPA Rules'
        TARGET_PATH: 'BPA_Rules'

    - task: PowerShell@2
      displayName: 'Upload Metadata Lakehouse Files'
      inputs:
        targetType: 'inline'
        script: |
          
          $pwshPath = 'C:\Program Files\PowerShell\7\pwsh.exe'
          $workspaceIds = ConvertFrom-Json -InputObject $env:WORKSPACE_IDS

          $workspaceId = $workspaceIds.PSObject.Properties.Value
          
          Write-Host "Uploading files to $workspaceId"

          & $pwshPath -File $scriptPath '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts/Fabric-LakehouseUpload.ps1'

        pwsh: false
        workingDirectory: '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts'
      env:
        FABRIC_TOKEN: $env:FABRIC_TOKEN
        WORKSPACE_IDS: $env:WORKSPACE_IDS
        LAKEHOUSE_NAME: 'den_lhw_pdi_001_metadata'
        SOURCE_PATH: 'src/metadata'
        TARGET_PATH: ''


    - task: PowerShell@2
      displayName: 'Run Ellie Notebooks'
      inputs:
        targetType: 'inline'
        script: |
          # Parse the JSON string of notebook IDs
          $notebookIds = $null
          try {
            $notebookIds = ConvertFrom-Json -InputObject $env:ELLIE_NOTEBOOK_IDS -ErrorAction Stop
            Write-Host "Found notebook IDs: $($notebookIds | ConvertTo-Json -Compress)"
          }
          catch {
            Write-Warning "Error parsing ELLIE_NOTEBOOK_IDS: $_"
            Write-Host "Raw value: $env:ELLIE_NOTEBOOK_IDS"
            exit 1
          }
          
          # Get workspace ID
          $workspaceIds = ConvertFrom-Json -InputObject $env:WORKSPACE_IDS
          $workspaceId = $workspaceIds.PSObject.Properties.Value
          Write-Host "Using workspace ID: $workspaceId"
          
          # Set up headers for API calls
          $Headers = @{
            "Authorization" = "Bearer $env:FABRIC_TOKEN"
          }
          
          # Track results
          $runResults = @()
          
          # Iterate through each notebook ID and run it
          foreach ($notebookId in $notebookIds) {
            try {
              Write-Host "Starting notebook: $notebookId"
              
              # Send request to start the notebook using WebRequest to get headers
              $startNotebookUrl = "https://api.fabric.microsoft.com/v1/workspaces/$workspaceId/items/$notebookId/jobs/instances?jobType=RunNotebook"
              $startResponse = Invoke-WebRequest -Uri $startNotebookUrl -Headers $Headers -Method POST -UseBasicParsing
              
              # Get the job URL from the Location header
              $notebookJobUrl = $startResponse.Headers["Location"]
              
              Write-Host "NotebookJobUrl: $notebookJobUrl"
            }
            catch {
              Write-Warning "Failed to run notebook $notebookId - Error: $_"
              $runResults += [PSCustomObject]@{
                NotebookId = $notebookId
                JobUrl = "Error"
                InitialStatus = "Failed"
                Error = $_.Exception.Message
              }
            }
          }

        pwsh: false
        workingDirectory: '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts'
      env:
        FABRIC_TOKEN: $env:FABRIC_TOKEN
        ELLIE_NOTEBOOK_IDS: $env:ELLIE_NOTEBOOK_IDS
        WORKSPACE_IDS: $env:WORKSPACE_IDS
    
    - task: PowerShell@2
      displayName: 'Remove temporary files'
      inputs:
        targetType: 'inline'
        script: |
          
          $pwshPath = 'C:\Program Files\PowerShell\7\pwsh.exe'

          & $pwshPath -File $scriptPath '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts/Remove-TempFiles.ps1'

        pwsh: false
        workingDirectory: '$(System.DefaultWorkingDirectory)/DevOpsServices/pipelines/scripts'        
